<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />

    <title>React Vertiefung</title>

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta
      name="apple-mobile-web-app-status-bar-style"
      content="black-translucent"
    />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui"
    />
    <link rel="stylesheet" href="slides/revealjs/reveal.js/dist/reset.css" />
    <link rel="stylesheet" href="slides/revealjs/reveal.js/dist/reveal.css" />
    <link
      rel="stylesheet"
      href="slides/revealjs/reveal.js/dist/theme/solarized.css"
    />

    <!-- Theme used for syntax hislides/ghlighted code -->
    <link
      rel="stylesheet"
      href="slides/revealjs/highlight-js-github-theme.css"
    />
    <link rel="stylesheet" href="slides/revealjs/styles.css" />
  </head>

  <body>
    <div class="reveal">
      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section data-state="title">
          <h2 class="title" style="font-size: 7rem">
            <b>React Vertiefung</b>
          </h2>

          <h4>
            <span class="transparent-bg">
              <a href="https://nilshartmann.net" target="_blank"
                >Nils Hartmann</a
              >
              |
              <a href="https://twitter.com/nilshartmann" target="_blank"
                >@nilshartmann</a
              >
            </span>
          </h4>
          <p style="margin-top: 4rem"></p>
          <div>
            <h3><span class="transparent-bg">Repository</span></h3>
            <p>
              <span class="transparent-bg"
                >Remote:
                <a
                  href="https://github.com/nilshartmann//react18-state-workshop"
                  >https://github.com/nilshartmann/react18-state-workshop</a
                ></span
              >
            </p>
          </div>
          <p style="margin-top: 4rem"></p>
          <div>
            <h3><span class="transparent-bg">Slides</span></h3>
            <p>
              <span class="transparent-bg"
                >Lokal: 2024-04-08-react-advanced.html</span
              >
            </p>
            <p>
              <span class="transparent-bg"
                >Remote:
                <a
                  href="https://nilshartmann.github.io/react18-state-workshop/2024-04-08-react-advanced.html"
                  >https://nilshartmann.github.io/react18-state-workshop/2024-04-08-react-advanced.html</a
                ></span
              >
            </p>
          </div>
        </section>
        <section>
          <h2>Nils Hartmann</h2>
          <p>
            <a href="https://nilshartmann.net" target="_blank"
              >https://nilshartmann.net</a
            >
            /
            <a href="https://twitter.com/nilshartmann" target="_blank"
              >@nilshartmann</a
            >
          </p>
          <p>
            <em
              >Freiberuflicher Software-Entwickler, Berater und Trainer aus
              Hamburg</em
            >
          </p>

          <div style="display: flex; justify-content: center">
            <div>
              <p>Java</p>
              <p>JavaScript, TypeScript</p>
              <p>React</p>
              <p>Single-Page-Applications</p>
              <p>GraphQL</p>
              <p style="margin-top: 20px">
                <a href="https://nilshartmann.net/workshops"
                  >Schulungen und Workshops</a
                >
              </p>
            </div>
            <div style="margin-left: 15px">
              <a href="https://reactbuch.de"
                ><img
                  style="max-height: 450px"
                  src="slides/images/react-buch-v2.jpg"
                /><br />https://reactbuch.de</a
              >
              <br />
            </div>
          </div>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h2>Grunds√§tzliches</h2>
          <p class="fragment">Bitte schaltet Euer Video ein üôè</p>
          <p class="fragment">
            <b>Jederzeit:</b> Fragen und Diskussionen! Bringt euch gerne ein.
          </p>
          <p class="fragment">Motto: Es gibt keine dummen Fragen!</p>
          <p class="fragment">
            Bemerkbar machen per Audio, "Hand heben" oder Chat
          </p>
          <p class="fragment">
            <img width="50%" src="slides/images/zoom-reaktionen.png" />
          </p>

          <p class="fragment">
            Ich zeige viel direkt im Editor, aber ihr k√∂nnt die Slides als
            Referenz benutzen
          </p>
          <p class="fragment">
            Wir machen zwischendurch √úbungen, in denen ihr selbst programmieren
            k√∂nnt
          </p>
        </section>
        <section data-markdown>
          <textarea data-template>
### Zeitplan
* Montag und Dienstag, 8. und 9. April
* Montag, 15. April
* jeweils 09.00 Uhr bis ca. 16.00 Uhr
  * 12.00 bis 13.00 Uhr Mittagspause üçù
  * Kurze Pausen zwischendurch ‚òïÔ∏è
---
## Agenda
<!-- .slide: class="no-fragment xleft" -->
**_"Vertiefung in React"_**
* [Context API](#/t-context)
* [Testen mit Jest (Einf√ºhrung)](#/t-test-jest)
* [Testen von React Komponenten und Hooks](#/t-testen-react)
* [Error Boundaries](#/t-error-boundaries)
* [Die Bibliothek "Zustand" f√ºr globalen Zustand (Basics: Stores, Actions, Change Detection)](#/t-zustand)
  * [Testen von Anwendungen mit Zustand](#/t-zustand-test)
* [Renderverhalten von React und Immutable Data](#/t-immutability)
* [Immutability mit Immer](#/t-immer)
* [Zustand Bibliothek: Middleware und Slices](#/t-zustand-2)
* **‚ÄûState of the Art‚Äú-Themen und k√ºnftige Features**
  * [Arbeiten mit Suspense f√ºr asynchrone und serverseitige Daten](#/t-async-data)
  * [Suspense](#/t-suspense)
  * Ausblick: Fullstack-Anwendungen am Beispiel Next.js

          </textarea>
        </section>

        <!-- ============================================================================== -->
        <!-- ====                                                                      ==== -->
        <!-- ====            C O N T E X T                                             ==== -->
        <!-- ====                                                                      ==== -->
        <!-- ============================================================================== -->
        <section id="t-context">
          <h3>Hintergrund: Daten und State</h3>
          <ul>
            <li>Serverseitige <b>Daten</b> und clientseitiger <b>State</b></li>
            <li>Arten von State: <b>lokal</b> und <b>global</b></li>
            <li>√úberblick: üëâ Daten und State</li>
          </ul>
        </section>
        <section>
          <h3>Hintergrund: Globaler Zustand</h3>
          <ul>
            <li>
              Man kann Zustand in <b>lokalen Zustand</b> und
              <b>globalen Zustand</b> einteilen
            </li>
            <li>
              <b>Lokaler Zustand</b> ist Zustand, der "mehr oder weniger" einer
              Komponente zur Verf√ºgung steht
            </li>
            <li>
              <b>Globaler Zustand</b> hingegen ist f√ºr die ganze Anwendung oder
              gro√üe Teile davon zust√§ndig
            </li>
            <li>Die √úbgerg√§nge sind flie√üend, es gibt keine fixe Definition</li>
            <li>
              Beispiele f√ºr globalen Zustand: angemeldeter Benutzer, Theme
            </li>
          </ul>
        </section>
        <section>
          <h2>React Context API</h2>
          <p>Kein Statemanagement, aber h√§ufig zusammen erw√§hnt</p>
          <p>"Dependency Injection"</p>
          <p>√úberblick: üëâ Anwendungshierachie mit State und Props (Miro)</p>
        </section>

        <!-- ============================================================================= -->

        <section>
          <h2>Im Detail: Context API</h2>
          <p>Beispiel: <code>20_context/workspace</code></p>
          <p>
            In <code>Container.tsx</code> Anzeige der Border einschalten (<code
              >hideBorder = false</code
            >)
          </p>
          <p><code>CounterApp</code> rendern!</p>
          <p>
            In <code>Container.tsx</code> Anzeige der Renderings einschalten
            (<code>showRenderings = true</code>)
          </p>
          <p>
            (Material in
            <code>context-example/material/CounterContext.txt</code>)
          </p>
        </section>

        <section>
          <h2>Context...</h2>
          <p>
            <em
              >erlaubt das Durchreichen von Informationen ohne explizites
              angeben als Properties</em
            >
          </p>

          <ul>
            <li>funktioniert nur innerhalb einer Hierarchie-Ebene</li>
            <li>
              es k√∂nnen beliebg viele (fachliche) Context definiert werden
            </li>
            <li>besteht aus <code>Provider</code> und <code>Consumer</code></li>
            <li>
              <a href="https://reactjs.org/docs/context.html" target="_blank"
                >Doku</a
              >
            </li>
          </ul>
        </section>

        <section>
          <h2>Context Factory</h2>
          <ul>
            <li>
              <em>erzeugt ein Objekt, mit <b>zwei Komponenten</b></em>
            </li>
            <li>
              <code>Provider</code>, stellt Objekt mit Key-Value-Paaren zur
              Verf√ºgung (der Context-"Value")
            </li>
            <li>
              <code>Consumer</code> wird in eigener Komponente verwendet, um auf
              einen Context zuzugreifen ("versteckt" durch useContext Hook)
            </li>
            <li>
              <pre><code class="line-numbers" data-leftpad>
import react from "React";

const AuthContext = React.createContext();

// erzeugt:
// AuthContext.Provider 
// AuthContext.Consumer (mit Hooks API √ºberfl√ºssig)

export AuthContext;
                      </code></pre>
            </li>
          </ul>
        </section>

        <section data-markdown>
          <textarea data-template>
## Context Factory mit TypeScript

* Der `createContext` kann ein Typ-Parameter √ºbergeben werden, der den Context-Wert beschreibt
* `createContext` ben√∂tigt dann einen Default-Wert, der diesem Typen entspricht
  * Der Default-Wert wird in der Anwendung in der Regel nicht verwendet
  * Wird nur verwendet, wenn (f√§lschlich) auf den Kontext zugegriffen wird, ohne dass es einen Provider
    gibt
* ```typescript
  type IAuthContext = { 
    username: string | null;
    onLogin(newUser: string): void;
    onLogout(): void;
  }

  const AuthContext = React.createContext<IAuthContext>({
    // Dummy-Implementierung vom Default Context
    username: null,
    onLogin() {},
    onLogout() {}
  });

  export AuthContext;
  ```

          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
## Context Provider

* _Eine React-Komponente, die einen Context zur Verf√ºgung stellt_
  * wird innerhalb einer eigenen Komponente eingebunden und zur√ºckgeliefert
  * Nimmt ein Objekt ("Context") mit beliebigen Werten entgegen (`value`-Property)
  * Woher die Werte kommen (State, Props, anderer Kontext, ...) spielt keine Rolle!
  * Alle Eintr√§ge des Objektes sind f√ºr die Konsumenten verf√ºgbar
* ```typescript
  const AuthContext = React.createContext&lt;IAuthContext>(/*...*/); // wie gesehen

  type AuthProviderProps = {
    children: React.ReactElement
  }

  export function AuthProvider(props: AuthProviderProps) {
      const [ currentUser, setCurrentUser ] = React.useState(null);

      const contextValue: IAuthContext = {
        // the current user
        currentUser,

        // function to set new user
        function onLogin(name) { setCurrentUser(name) },
        function onLogout() { setCurrentUser(null) }
      };

      return &lt;AuthContext.Provider value={contextValue}>
        {props.children}
      &lt;/AuthContext.Provider>;
  }             
  ```
  </textarea
          >
        </section>

        <section>
          <h2>useContext-Hook</h2>
          <p><em>Zugriff auf die Werte aus dem Context</em></p>
          <p>
            In allen Komponenten unterhalb der Provider Komponente, kann mit
            <code>useContext</code> auf den Kontext zugegriffen werden
          </p>

          <pre><code class="javascript">
import { AuthContext } from "auth-context";

function UserBadge() {
  const { currentUser } = React.useContext(AuthContext);

  return currentUser  ? &lt;h1>Welcome, {currentUser}&lt;h1> : null;
}            
          </code></pre>

          <p>Aufrufen einer Funktion aus dem Context</p>
          <p>√Ñndert im Context den Zustand der Provider-Komponente</p>
          <p>
            Alle Konsumer werden neu gerendert und k√∂nnen den neuen Wert
            verwenden
          </p>
          <pre><code class="javascript">
function UserBadge() {
  const { currentUser, logout } = React.useContext(AuthContext);

  return currentUser  ? 
    &lt;>&lt;h1>Welcome, {currentUser}&lt;h1>&lt;button onClick={logut}>Logout&lt;/button>&lt;/> 
    : null;
}                
          </code></pre>
        </section>

        <section data-markdown>
          <textarea data-template>
## Zugriff mit Custom Hook

* √úbliches Pattern: f√ºr den Zugriff auf den Context wird ein eigener Hook zur Verf√ºgung gestellt
* ```typescript
  export function useAuthContext(): IAuthContext {
    const authContext = useContext(AuthContext);

    return authContext;
  }            
  ```
* ```typescript
  import { useAuthContext } from "auth-context";
  
  export default function UserBadge() {
    const authContext = useAuthContext();
  }
  ```  

  * "Versteckt" den Context (Implementierungsdetail!) vor der Anwendung
  * Sieht aus wie fachliche API
  * Kann (vergleichsweise einfach) gemockt werden
---
###  Zugriff mit Custom Hook in TypeScript
* Beim Erzeugen des Context muss man (in TypeScript) einen Default Context angeben:
* ```typescript
  const defaultContext: IAuthContext = {
      // Dummy-Implementierung vom Default Context
      username: null, onLogin() {}
  }
  const AuthContext = React.createContext<IAuthContext>(defaultContext);
  ```
* Das ist nicht immer (sinnvoll) m√∂glich, so dass man auch `ContextType | null` verwenden k√∂nnte:
* ```typescript
  const AuthContext = React.createContext<IAuthContext | null>(null);
  ```
* Nun liefert `useContext` aber immer auch `null` zur√ºck, so dass die Verwendung jedes Mal √ºberpr√ºft werden muss:
* ```typescript
  function UserBadge() {
    const { username } = useContext(AuthContext); // ERR: Property 'username' does not exist on type 'IAuthContext | null'
  }
  ```
 
* Mit dem Custom Hook kann eine Plausibilit√§tspr√ºfung durchgef√ºhrt werden und ggf. ein sprechender Fehler erzeugt werden:
* ```typescript
  
  export function useAuthContext(): IAuthContext {
    const authContext = useContext(AuthContext);

    if (authContext === null) {
      throw new Error("AuthContext not correctly initialized. Please wrap your application in a AuthContextProvider component");
    }

    return authContext;
  }            
  ```  

---
### Ein "halbglobaler" Context
<!-- .slide: class="left" -->
* Ein Formular hat eine beliebige Menge von Feldern und Button
* Kann man da mit Context was machen? ü§î

* ```typescript
  
    type FormState = Record<string, string>;

    function PersonForm() {
      const [formState, setFormState] = React.useState<FormState>({});

      function onClearForm() {
        setFormState({});
      }

      function onFieldChange(fieldname: string, value: string) {
        setFormState({
          ...formState,
          [fieldname]: value
        });
      }

      return (
        <Container title="PersonForm">
          <FieldSet>
            <Input name="firstname" formState={formState} onFieldChange={onFieldChange} />
            <Input name="lastname" formState={formState} onFieldChange={onFieldChange} />
          </FieldSet>
          <ClearButton onClearForm={onClearForm} />
        </Container>
      );
    }

  ```

---
## √úbung: Ein Notification Context

* *Baue einen Kontext, der eine globale Notification anzeigt*
* <!-- .element: class="demo" -->Ergebnis zeigen
* Schritte:
  * In `20_context/workspace` bitte Abh√§ngigkeiten installieren und npm starten:
  * ```bash
    cd 20_context/workspace

    npm install
    npm start 
    ```
* In `NotificationContext.tsx` soll ein Context implementiert werden, der Informationen
            √ºber die anzuzeigene Notification enth√§lt
* In `NotificationApp.tsx` sind React-Komponenten implementiert. Diese sollen den Context dann nutzen
* N√§here Informationen findest Du direkt in beiden Dateien
* Du solltest mit der Implementierung des `NotificationContext` anfangen
* M√∂gliche L√∂sung findest Du in `material/02_solution`
* Wenn Du fertig bist, bitte "Hand heben" in Zoom üôãÔ∏è

---
### Renderverhalten von Context

* Lasst uns mal √ºberlegen, ob es sinnvoll ist, f√ºr die Verwendung unseres `NotificationContext` mehrere Hooks zu bauen:
  * zum Beispiel zum Setzen des Context
  * zum Beispiel zum Zugriff nur auf die √ºbersetzte Message
  * ...oder auch nur auf die Information, ob √ºberhaupt etwas gesetzt ist
* hilft uns das beim Optimieren des Renderings? ü§î
* was f√ºr einen Vor- oder Nachteil h√§tte dieser Ansatz dar√ºberhinaus? ü§î
---
### Renderverhalten von Context

* Bei jeglicher √Ñnderung des Contexts werden immer alle Konsumenten neu gerendert
  * unabh√§ngig davon, ob diese sich f√ºr den Teil interessieren, der sich ge√§ndert hat
  * das k√∂nnen wir nicht vermeiden (evtl. in einer kommenden React Version)
* Aus diesem Grund sollte man den Context nicht unbedingt verwenden, wenn
  * darin Daten enthalten sind die sich h√§ufig bzw. schnell √§ndern (Inhalt eines Eingabefeldes z.B.)
  * und von diesen √Ñnderungen sehr viele Komponenten betroffen sind (direkt oder indirekt)


---
### Neuerungen in React 19
<!-- .slide: id="t-react19" --> 

* [React 19](https://react.dev/blog/2024/02/15/react-labs-what-we-have-been-working-on-february-2024) wird im Laufe des Jahres erscheinen
* Darin wird sich auch die Context API ver√§ndern:
  * Es wird eine `Context`-Komponente geben (ersetzt `Context.Provider`)
  * `useContext` wird durch den `use`-Hook ersetzt
  * Der `use`-Hook ist flexibler als die bisherigen Hooks
  * Kann √ºberall verwendet werden (z.B. in `if`)
  * Das ganze ist (weitgehend) abw√§rtskompatibel! 
* Die APIs `useCallback`, `useMemo` und `memo` werden durch den **React Compiler** (ehem. Codename: "Forget") ersetzt
  * Unklar, ob der Compiler Teil von React 19 wird, da es ein eigenes Projekt ist



          </textarea>
        </section>
        <section id="t-test-jest">
          <h1>Testen</h1>
        </section>
        <section data-transition="slide none">
          <h2>Was testen wir?</h2>
          <ul>
            <li>
              <b>UI-unabh√§ngige Logik</b> (zum Beispiel Backend Calls,
              Berechnungen etc.)
            </li>
            <li>
              <b>Rendering</b> (Ist die Liste der Blog Posts korrekt? Sieht das
              Markup aus, wie wir uns das vorstellen?) und
              <b>Interaktionen</b> (funktionieren die Event Handler, die
              Callback-Funktionen, der Programmflu√ü etc.?)
            </li>
            <li>
              <b>Verhalten im Browser</b> (z.B. korrekte, pixelgenaue
              Darstellung, Browser-spezifisches JavaScript, Arbeiten mit
              Browser-Technologie wie Titelzeile, Session Storage, Scrollbars
              etc)
            </li>
          </ul>
        </section>

        <section>
          <h1>Jest</h1>
          <p>
            <em
              >"Delightful JavaScript Testing" (
              <a href="https://jestjs.io/" target="_blank">https://jestjs.io/</a
              >)</em
            >
          </p>
          <p>Vollst√§ndige Testl√∂sung f√ºr React (und andere):</p>
          <ul>
            <li>Test Runner</li>
            <li>Specs/Assertions, Mocks</li>
            <li>Code Coverage</li>
          </ul>
        </section>
        <section>
          <h1>Vitest</h1>
          <p class="fragment">
            Falls ihr mit Vite arbeitet, bietet sich
            <a href="https://vitest.dev/"> Vitest </a> an.
          </p>
          <ul>
            <li>
              Das ist deutlich moderner als Jest und arbeitet auch besser mit
              dem ECMAScript Modulsystem (ESM) und TypeScript zusammen
            </li>
            <li>
              Vitest hat eine sehr √§hnliche API wie Jest und ein vergleichbares
              Feature-Set
            </li>
            <li>
              Es gibt auch einen<a
                href="https://vitest.dev/guide/migration.html#migrating-from-jest"
                >Migrationspfad von Jest</a
              >
            </li>
          </ul>
        </section>
        <section>
          <h4>Jest</h4>
          <h3>Beispiel: Ein einfacher Testfall</h3>
          <pre><code class="javascript">// sum.js (or sum.ts)
export const sum = (a,b) => a+b;
        </code></pre>
          <pre><code class="javascript">// sum.test.js
import {sum} from '../sum.js';

test('sum of 2 and 2 is 4', () => {
  expect(sum(2, 2)).toBe(4);
});

test('sum of 2 and 2 is not 3', () => {
  expect(sum(2, 2)).not.toBe(3);
});
            </code></pre>
        </section>
        <section>
          <h4>Jest</h4>
          <h2>Testcases</h2>
          <p>
            <code>test</code> oder
            <code>it</code>
          </p>
          <pre><code>test('it should work', () => {
  expect(...).toBe(...);
});</code></pre>
          <pre><code>it('it should also work', () => {
  expect(...).toBe(...);
});</code></pre>
        </section>

        <section>
          <h4>Jest</h4>
          <h2>"Expectations" und "Matchers"</h2>
          <div>
            <p>
              <code>expect()</code> liefert ein <em>Expectation</em> Objekt
              zur√ºck, das verschiede <em>Matcher</em> Funktionen bereitstellt:
            </p>
            <pre><code>expect(actual).toXyz(expected);
// for example:
expect("Hello Jest").toBe("Hello Jest"); // => ok
        </code></pre>
          </div>
          <div>
            <p>Beispiele f√ºr Matchers</p>

            <pre><code>// Compare identity
expect(actual).toBe(expected);
// Compare value:
expect(actual).toEqual(expected);
// true / false / null:
expect(actual).toBeTruthy();
expect(actual).toBeFalsy();
expect(actual).toBeNull();
// Length (Array oder String)
expect(actual).toHaveLength(123);
        </code></pre>
          </div>
          <p>
            <a href="https://jestjs.io/docs/en/expect"
              >https://jestjs.io/docs/en/expect</a
            >
          </p>
        </section>

        <section>
          <h4>Jest</h4>
          <h2>Mock Funktionen</h2>
          <ul>
            <li>
              <code>jest.fn()</code> erzeugt eine Mock-Funktion
              <pre><code>// Gibt undefined zur√ºck, wenn die Mock-Funktion ausgef√ºhrt wird
const aMockFn = jest.fn();

const x = aMockFn("hello", "world"); // => undefined
expect(x).toBeUndefined();
              </code></pre>
            </li>
            <li>
              Mit <code>toHaveBeenCalled</code>-Matcher-Funktionen kann gepr√ºft
              werden, ob der Mock aufgerufen wurde, wie h√§ufig und mit welchen
              Parametern:
              <pre><code>
expect(aMockFn).toHaveBeenCalled());  // Mock wurde aufgerufen (Parameter werden ignoriert)
expect(aMockFn).toHaveBeenCalledWith("hello", "world")); // Mock wurde mit 'huhu' aufgerufen
expect(aMockFn).toHaveBeenCalledTimes(1)); // Mock wurde genau einmal aufgerufen

// √úbergebene Paramter stehen √ºber .mock.calls:
expect(aMockFn.mock.calls[0][0]).toBe("hello");
expect(aMockFn.mock.calls[0][1]).toBe("world");
                      </code></pre>
            </li>
            <li>
              Implementierung der Mock-Funktion kann als Parameter √ºbergeben:
              <pre><code>
        const aMockFn = jest.fn( param => `Hello, ${param}` );

        console.log(aMockFn('World'));
        // => Hello, World
                  </code></pre>
            </li>
          </ul>
        </section>
        <section>
          <h4>Jest</h4>
          <p><b>Achtung:</b></p>
          <p>
            Je nach Jest-Version und Setup m√ºsst ihr das
            <code>jest</code>-Objekt importieren
          </p>
          <p><code>import { jest } from "@jest/globals";</code></p>
          <p>
            (Die <code>test</code>-Funktion funktioniert in der Regel ohne
            import...)
          </p>
        </section>

        <section id="t-testen-react">
          <h3>Testen von React Komponenten und Hooks</h3>
        </section>

        <section>
          <h3>react-testing-library</h3>
          <p>
            <em
              >"Simple and complete React DOM testing utilities that encourage
              good testing practices."
            </em>
          </p>

          <p>
            <a
              href="https://github.com/testing-library/react-testing-library"
              target="_blank"
              >https://github.com/testing-library/react-testing-library</a
            >)
          </p>
          <p>
            Philosophie: Tests werden aus User-Perspektive geschrieben. Das
            bedeutet, um die zu testenden Elemente zu finden, suchst Du nach
            Eigenschaften, nach denen auch ein User suchen w√ºrde (z.B. Labels,
            Placeholder etc.)
          </p>
        </section>
        <section>
          <h3>react-testing-library</h3>
          <p>Example</p>
          <p>Demo: 20_context/workspace/src/__tests__/PostEditor.test.tsx</p>
          <pre><code class="javascript">
            import { render, screen } from "@testing-library/react";
            import _userEvent from "@testing-library/user-event";
            import { jest } from "@jest/globals";


            it("invokes callback on button click", () => {
              const user = _userEvent.setup();

              const onAddPostFn = jest.fn();

              // Render
              render(&lt;PostList onAddPost={onAddPostFn} posts={mockPosts} />);

              // search the button
              const buttonElement = screen.getByRole("button", { name: "Add Post" });

              // "click" the button
              await user.click(buttonElement);

              // make sure it has been invoked
              expect(onAddPostFn).toHaveBeenCalled();
            });

            </code></pre>
        </section>

        <section>
          <h3>React Testing Library im Detail</h3>
        </section>

        <section>
          <h3>Die render-Funktion</h3>
          <ul>
            <li>
              Die render-Function aus der react-testing-library wird im Test
              verwendet, um eine React Komponente (ohne Browser) zu rendern
            </li>
            <li>
              Genauso wie in der Anwendungen k√∂nnen Properties angegeben werden
            </li>
            <li>
              <pre><code class="javascript">
import { render } from "@testing-library/react";

// Render a single component
render(&lt;PostList onAddPost={onAddPostFn} posts={mockPosts} />);
            </code></pre>
            </li>
            <li>
              Dran denken, ggf. Contexte ebenfalls zu erzeugen, falls diese
              ben√∂tigt werden (eigener Context, Router, MaterialUI, etc)!
            </li>
            <li>
              <pre><code class="javascript">

// Render with surrounding Redux Provider (or Router, your own Context etc.)
render(
  &lt;NotificationContextProvider>
    &lt;PostEditor onSavePost={onSavePostFn}  />
  &lt;/NotificationContextProvider>
);
            </code></pre>
            </li>
          </ul>
        </section>

        <!-- ######################################################################################### ########################## -->

        <section>
          <h3>query Funktionen</h3>
          <p>
            Um die gerenderten HTML-Elemente aus deiner Komponente zu √ºberpr√ºfen
            und mit ihnen zu interagieren, musst Du sie ersteinmal finden ü§ì
          </p>
          <p>
            Auf dem globalen <b>screen</b> Objekt der Testing-Lib sind
            verschiedene Funktionen definiert, mit denen Du nach Elementen
            suchen kannst
          </p>
          <p>
            Die query-Funktionen haben unterschiedliche <b>Suffixe</b>, die
            beschreiben, <b>nach welchem Kriterium</b> Du suchst (nach Label,
            nach aria-role, ...)
          </p>
          <p>
            Die Funktionen haben au√üerdem jeweils einen <b>Pr√§fix</b> (getBy,
            queryBy etc) der beschreibt, die Art des R√ºckgabewerts der jeweilgen
            Funktion (z.B. ob sie einen Error wirft oder null zur√ºckgibt, wenn
            das angefragte Element nicht gefunden wurde)
          </p>
          <p>
            Mehr zu den query-Funktionen:
            <a
              target="_blank"
              href="https://testing-library.com/docs/react-testing-library/cheatsheet#queries"
              >React Testing Library Cheatsheet</a
            >
          </p>

          <pre><code class="javascript">
  // BEISPIELE:
  import { screen } from "@testing-library/react";

  // suche nach einem Button (Annahme: es gibt GENAU EINEN, ansonsten schl√§gt der Test fehl)
  const buttonElement = screen.getByRole("button", { name: "Add Post" });

  // suche nach einem Button (gibt null oder EINEN Button, wirft ansonst einen Fehler)
  const buttonElement = screen.queryByRole("button", { name: "Add Post" });
  // das verwendet man eigentlich nur, um zu testen, dass ein Element NICHT vorhanden ist:
  expect(screen.queryByRole("button", { name: "Create Post" })).not.toBeInTheDocument();

  // suche nach einem Button (gibt alle gefunden zur√ºck oder ein leeres Array)
  const buttonElement = screen.queryAllByRole("button", { name: "Add Post" });
</code></pre>
        </section>

        <section>
          <h3>√úberpr√ºfen von Elementen</h3>
          <p>
            Wenn Du dein gesuchtes Elemente gefunden hast, kannst Du es
            √ºberpr√ºfen, ob es deinen Erwartungen entspricht (korrekte Attribute
            gesetzt etc.)
          </p>
          <p>
            Die Bibliothek
            <a
              href="https://github.com/testing-library/jest-dom"
              target="_blank"
              >jest-dom</a
            >
            f√ºgt dazu DOM-spezifiche Matcher f√ºr Jest hinzu.
          </p>

          <pre><code class="javascript">
  import { screen } from "@testing-library/react";

  expect(screen.getByRole("button", { name: "Add Post" })).toBeInTheDocument();

  // stellt sicher, dass das Element im DOM vorhanden ist (getBy-Query w√ºrde hier vielleicht mehr Sinn machen)
  expect(buttonElement).toBeInTheDocument();

  // sicherstellen, dass ein Eingabefeld einen erwarteten Wert hat
  expect(titleInput).toHaveValue("Moin moin");

  // sicherstellen, dass ein Button disabled ist
  expect(okButton).toBeDisabled();
</code></pre>
          <p>
            Alle Matcher sind auf der oben verlinkten GitHub Seite dokumentiert
          </p>
        </section>
        <section>
          <h3>Interaktionen</h3>
          <p>
            Du kannst mit den Elementen interagieren, in dem Du ihnen Events
            sendest, genau wie es ein Browser tun w√ºrde
          </p>
          <p>
            Es gibt eine weitere Bibliothek,
            <a
              href="https://github.com/testing-library/user-event"
              target="_blank"
            >
              user-event</a
            >, die dir dabei hilft, die Events zu erzeugen.
          </p>

          <pre><code class="javascript">
            import userEvent from "@testing-library/user-event";
            // Simuliert die Eingabe in ein Textfeld
            userEvent.type(titleInput, "New Title");

            // Simuliert den Klick auf einen Button
            userEvent.click(clearButton);
          </code></pre>
          <p>
            Achtung! In neueren Versionen (ab v14) der Bibliothek muss man erst
            setup-Aufrufen.
          </p>
          <p>
            Au√üerdem sind die Funktionen nun asynchron, so dass Du mit
            <code>await</code> auf deren Beendigung warten musst!
            <b>Das ist ganz wichtig!</b>
          </p>
          <pre><code class="javascript">
            import _userEvent from "@testing-library/user-event";

            test("...", async () => {
              const userEvent = _userEvent.setup();
              // Simuliert die Eingabe in ein Textfeld
              await userEvent.type(titleInput, "New Title");

              // Simuliert den Klick auf einen Button
              await userEvent.click(clearButton);
            })
          </code></pre>
          <p>Alle Events sind auf der GitHub Seite beschrieben (Link oben)</p>
        </section>

        <section data-markdown>
          <textarea data-template>
## Der Testing Playground

* https://testing-playground.com/
* Hier kann man HTML-Code reinkopieren, mit dem man dann Query-Funktionen ausprobieren kann
* Dazu gibt es auch eine Browser-Erweiterung f√ºr [Chrome](https://chrome.google.com/webstore/detail/testing-playground/hejbmebodbijjdhflfknehhcgaklhano)
* Mit `screen.logTestingPlaygroundURL()` kann man eine URL ausgeben lassen, die den im Test gerenderten HTML-Code direkt im Playground √∂ffnet
          </textarea>
        </section>
        <section data-markdown>
          <textarea data-template>
## √úbung: Tests f√ºr den PostEditor

* Im Workspace-Verzeichnis (`20_context/workspace`) gibt es einen PostEditor
* Um den auszuprobieren kannst Du den in `main.tsx` rendern lassen (statt `NotificationApp`)
* F√ºr diesen PostEditor solltest Du einige Tests schreiben
* Ein "Template" daf√ºr ist bereits im `__tests__`-Ordner vorhanden
* Ausf√ºhren kannst Du die Tests mit `npm test`
  * Dieser Prozess l√§uft "ewig" und f√ºhrt die Tests automatisch beim Speichern aus
* Alternativ kannst Du die Tests auch in IDEA ausf√ºhren
* L√∂sung: `material
* Wenn Du fertig bist, bitte "Hand heben" üôã‚Äç
          </textarea>
        </section>
        <section data-markdown>
          <textarea data-template>
### Testen von (Custom) Hooks

* Hooks k√∂nnt ihr nicht "einfach so" aufrufen und Testen, denn die setzen zur Laufzeit ja die React Infrastruktur voraus
* Es gibt zwei M√∂glichkeiten:
  1. Ihr schreibt euch im Test eine Wrapper-Komponente, die den Hook verwenden und testet die dann "wie gewohnt"
  2. Ihr verwendet `renderHook`
* <!-- .element: class="demo" --> `useCounter.test.tsx`
---
### renderHook
* `renderHook` erwartet eine Callback-Funktion. In dieser Callback-Funktion k√∂nnt ihr euren Hook dann aufrufen.
* Als Beispiel soll folgender Custom Hook dienen, der ein Objekt mit einem  Z√§hler und eine Funktion zum Hochsetzen des Z√§hlers zur√ºckliefert:
* ```typescript
  // Diesen Hook wollen wir testen:
  function useDemoCounter() {
    const [count, setCount] = useState(100);

    function increaseCount() { setCount(count + 1); }

    return { count, increaseCount };
  }
  ```
* Zum "rendern" dieses Hooks verwendet ihr `renderHook` aus der testing-library:
* ```typescript

  import { renderHook } from "@testing-library/react";

  test("useDemoCounter Works", () => {
    const { result } = renderHook(() => useDemoCounter());

    // ....
  });
  ```
---
### renderHook
* `renderHook` liefert ein Objekt zur√ºck, das unter anderem ein `result` Property kennt
* Darauf wiederrum ist das `current`-Property definiert, das den R√ºckgabewert eures Hooks enth√§lt
* Dieses k√∂nnt ihr zum √úberpr√ºfen der Daten verwenden:
* ```typescript
  test("useDemoCounter Works", () => {
    const { result } = renderHook(() => useDemoCounter());

    expect(result.current.counter).toBe(100);
  });

  ```
---
### Neurendern des Hooks
* Im Test k√∂nnt ihr nicht einfach Funktionen aufrufen, die Euer Hook bereitstellt, die dann die React API verwenden
  * In unserem Fall z.B. geht `result.current.increaseCounter()` nicht, weil darin der State ver√§ndert wird
* In solchen F√§llen m√ºsst ihr den Aufruf mit der `act`-Funktion aus der testing-library wrappen.
* Nach dem Aufruf ist das `result.current` Objekt dann automatisch das aktualisierte R√ºckgabe-Objekt eures Hooks
* ```typescript
  import { act, renderHook } from "@testing-library/react";

  test("useDemoCounter Works", () => {
    const { result } = renderHook(() => useDemoCounter());

    act( () => result.current.increaseCounter() );

    // 'result.current' ist hier automatisch das aktualisierte R√ºckgabe-Ergebnis,
    // das euer Hook in React nach dem neu-rendern zur√ºckliefern w√ºrde
    expect(result.current.counter).toBe(100);
  })
  ```
---
### Testen eines Contexts
* K√∂nnen wir mit den gezeigten Mitteln unseren `useNotification`-Hook testen? ü§î
* Ja, aber...
* Der Hook setzt ja voraus, dass die Provider-Komponente auch gerendert ist!
* Die `renderHook`-Funktion ist darauf vorbereitet. Denn intern generiert sie bereits eine Komponente, die sie im Test um euren Hook herumlegt
* Und diese interne Komponente k√∂nnen wir auch explizit setzen!
* Dazu gibst Du eine `wrapper`-Funktion als zweiten Parameter beim Aufruf von `renderHook` an
* Diese `wrapper`-Funktion muss eine Komponente zur√ºckliefern, die alle erforderlichen Kontexte etc. enth√§lt
* Als Parameter erh√§lt die `wrapper`-Funktion das `children`-Property, dass Du in deiner "Dummy-Komponente" verwenden musst:
* ```typescript
  test("context works", () => {
    const {result} = renderHook(

      // erster Parameter: wie eben schon im useCounter-Beispiel
      () => useNotificationContext(),

      // zweiter Parameter: die wrapper-Komponente
      { wrapper: ({ children }) => (
        <NotificationContextProvider>{children}</NotificationContextProvider>
      )},
    });

    expect(result.current.messageId).toBe(null);
    // ...
  })

  ```
---
## √úbung: Test f√ºr den Notification Context
* Schreibe einen Test f√ºr den NotificationContext
* Du kannst selbst entscheiden, was der beste Weg f√ºr dich ist bzw. welche(n) Du ausprobieren m√∂chtest.
  1. Test-Komponente schreiben, die den Context verwendet und dann die Ausgaben der Test-Komponente √ºberpr√ºfen
  2. `renderHook`-Verwenden
* Eine Vorlage findest Du in `20_context/workspace/__tests__/NotificationContext.test.tsx`
* Eine m√∂gliche L√∂sung findest Du in `20_context/material/04_test_context`
* Bei Fragen oder Problemen kannst Du dich jederzeit melden
* Wenn Du fertig bist, bitte die Hand heben ‚úã
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
## Error Boundaries
<!-- .slide: id="t-error-boundaries" -->
* ü§îWas passiert, wenn wir in unserer App vergessen, den `NotificationContextProvider` einzubinden? ü§î
* <!-- .element: class="demo" -->Ausprobieren (NotificationApp.tsx)
---
## Error Boundaries

* Wenn beim **Rendern** etwas schiefgeht, verwirft React "zur Sicherheit" den ganzen Komponenten-Tree
  * (damit nicht z.B. inkonsistente oder fehlerhafte Daten angezeigt werden)
* Das ist nicht besonders benutzerfreundlich
* In einem Event-Handler haben wir dieses Problem nicht: dort k√∂nnen wir z.B. mit try/catch arbeiten
  * oder der Event-Handler wird einfach abgebrochen und die "alte" UI bleibt weiterhin sichtbar
* Beim Rendern k√∂nnen wir aber kein try/catch drumherum legen
* Deswegen gibt es "spezielle" Komponenten: **Error Boundaries**
---
### Error Boundaries
* Error Boundary-Komponenten kann man √ºberall in seiner Komponenten-Hierarchie einziehen
* Render-Fehler, die unterhalb auftreten, werden dann der Error Boundary-Komponente √ºbergeben
  * Diese kann dann z.B. eine Fehler-Komponente darstellen
  * Dieses Verhalten √§hnelt try-catch.
  * Auch try-catch-Bl√∂cke in "normalem" Code k√∂nnt ihr ja auf jeder Ebene des Call-Stacks einziehen
* Ein Beispiel:
* ```typescript
  function MyApp() {
    return (
      <Layout>
        <Header />
        <MyErrorBoundary>
            <Main>
              <BlogPost />
            </Main>
            <NewsletterForm />
        </MyErrorBoundary>
      </Layout>
    )
  }
  ```
* Wenn es hier zum Fehler **w√§hrend des Renderns** kommt:
  * innerhalb von `Layout` oder `Header`: wei√üe Seite, Fehlermeldung auf der Console
  * innerhalb von `Main`, `BlogPost` oder `NewsletterForm`: Error Boundary wird angezeigt, `Layout` und `Header`-Komponente bleiben unver√§ndert (gerendert)
---
### Error Boundaries
* Eine Error Boundary-Komponente ist eine Art `catch`-Block f√ºr die Renderphase von Komponente
* Technisch handelt es sich dabei um eine fast "normale" React-Komponente
* Diese muss allerdings noch mit der (alten) React JavaScript Klassen API gebaut werden
* Diese Klasse muss dann die [getDerivedStateFromError](https://react.dev/reference/react/Component#static-getderivedstatefromerror) Callback-Funktion implementieren
* Einfacher ist es, eine fertige Error Boundary-Komponente zu verwenden: [react-error-boundary](https://github.com/bvaughn/react-error-boundary)
---
### Error Boundary mit `react-error-boundary`
* Die Error Boundary-Komponente aus der Bibliothek hei√üt - √úberraschung! - `ErrorBoundary`
* Die ist sehr flexibel zu konfigurieren
* Man muss ihr eine Komponente √ºbergeben die im Falle eines Fehlers gerendert werden soll
  * (das ist euer "try-Block")
* Diese Komponente bekommt dann als Property u.a. den Fehler √ºbergeben:
* ```typescript
  import { FallbackProps } from "react-error-boundary";

  function AppErrorMessage( { error }: FallbackProps) {

    console.error("Something bad happend:", error);
    return <h1>Something bad happend !</h1>;
  }
  ```
* ```typescript
  import { ErrorBoundary } from "react-error-boundary";
  function MyApp() {
    return (
      <Layout>
        <Header />
        <ErrorBoundary fallback={AppErrorMessage}>
            <Main>
              <BlogPost />
            </Main>
            <NewsletterForm />
        </ErrorBoundary>
      </Layout>
    )
  }

  ```
---
### react-error-boundary
* Der `fallback`-Komponente wird √ºberdies eine Funktion `resetErrorBoundary` √ºbergeben
* Die k√∂nnt ihr aufrufen, dann wird erneut versucht, den Komponenten-Tree unterhalb der `ErrorBoundary`-Komponente zu rendern
* Das macht Sinn wenn es Grund zur Annahme gibt, der Fehler verschwinde sp√§ter (z.B. Netzwerkverbindung ist wieder in Ordnung)
* ```typescript
  import { FallbackProps } from "react-error-boundary";

  function AppErrorMessage( { error, resetErrorBoundary }: FallbackProps) {

    console.error("Something bad happend:", error);
    return (
      <div>
        <h1>Something bad happend !</h1>
        <button onClick={ () => resetErrorBoundary() }>Try again!</button>
      </div>
    );
  }
  ```
* Wenn ihr eine M√∂glichkeit habt, einen fehlerhaften Zustand zu reparieren, k√∂nnt ihr an der `ErrorBoundary`-Komponente eine `onReset`-Funktion angeben
* Diese wird dann aufgerufen, wenn ihr `resetErrorBoundary` in der Fallback-Komponente aufruft
---
### react-error-boundary

* Normalerweise werden Error Boundary-Komponenten von React nur dargestellt, wenn ein Fehler **beim Rendern** auftritt
* Die `ErrorBoundary`-Komponente von `react-error-boundary` k√∂nnt ihr aber auch manuell rendern lassen, wenn z.B. in einem Event ein Fehler auftritt.
  * So k√∂nnt ihr eure Fehlerbehandlung dann auf alle Arten von Fehlern in eurer Anwendung anwenden
* Um die `ErrorBoundary`-Komponente anzuzeigen, verwendet ihr den `useErrorBoundary`-Hook:
* ```typescript
  import { useErrorBoundary } from "react-error-boundary";

  function PostEditor() {
    const { showBoundary } = useErrorBoundary();

    async function saveBlogPost() {
      try {
        await fetch("...");
      } catch (e) {
        showBoundary("Could not save blog post");
      }
    }
    return ...;
  }
  ```
* Genau wie bei Error Boundaries, die beim Rendern aktiv werden, wir hier auch die n√§chsth√∂here `ErrorBoundary`-Komponente angezeigt

  </textarea
          >
        </section>

        <section>
          <h3>Exkurs: Error Boundary selbstgebaut</h3>
          <p class="fragment">
            <b>getDerivedStateFromError</b> und <b>componentDidCatch</b> werden
            von React im Fehlerfall aufgerufen
          </p>
          <pre
            class="fragment"
          ><code class="javascript" contenteditable data-trim>
              class ErrorHandler extends React.Component {
                constructor(props) {
                  super(props);
                  this.state = { error: null };
                }

                static getDerivedStateFromError(error) {
                  return { error: error.toString() };
                }

                componentDidCatch(error, info) {
                  console.error("uups... we caught an error", error, info);
                }

                render() {
                  if (this.state.error) {
                    return (
                      &lt;div>
                        &lt;h1>An error occured!&lt;/h1>
                        &lt;pre>{this.state.error}&lt;/pre>
                        &lt;button onClick={() => this.setState({ error: null })}>Try again&lt;/button>
                      &lt;/div>
                    );
                  }
                  return this.props.children;
                }
              }
            </code></pre>
        </section>

        <section>
          <h3>Exkurs: Error Boundary selbstgebaut</h3>
          <h4>Lifecycle</h4>

          <div style="display: flex">
            <pre><code class="javascript" contenteditable data-trim>
                  class ErrorHandler extends React.Component {
                    constructor(props) {
                      super(props);
                      this.state = { error: null };
                    }

                    static getDerivedStateFromError(error) {
                      return { error: error.toString() };
                    }

                    componentDidCatch(error, info) {
                      console.error("uups... we caught an error", error, info);
                    }

                    render() {
                      if (this.state.error) {
                        return (
                      &lt;div>
                         &lt;h1>An error occured!&lt;/h1>
                        &lt;pre>{this.state.error}&lt;/pre>
                        &lt;button onClick={() => this.setState({ error: null })}>Try again&lt;/button>
                      &lt;/div>
                        );
                      }
                      return this.props.children;
                    }
                  }
                </code></pre>

            <ol>
              <li class="fragment">
                Komponente wird instantiiert, Konstruktor aufgerufen, State
                vorbelegt (error = null)
              </li>
              <li class="fragment">
                Komponente wird gerendert. Da
                <code>this.state.error</code> nicht gesetzt ist, werden die
                Children gerendert
              </li>
              <li class="fragment">
                Fehler tritt in Unterkomponente beim Rendern auf
              </li>
              <li class="fragment">
                <code>componentDidCatch</code> wird aufgerufen (Fehler kann z.B.
                protokolliert werden)
              </li>
              <li class="fragment">
                <code>getDerivedStateFromError</code> wird aufgerufen und
                liefert einen neuen Teil-State zur√ºck. <br />(Andere Teile des
                States bleiben unver√§ndert)
              </li>
              <li class="fragment">
                Komponente wird erneut gerendert. Da
                <code>this.state.error</code> jetzt gesetzt ist, wird die
                Fehlermeldung angezeigt, inklusive des Buttons
              </li>
              <li class="fragment">
                Nach dem Klick auf den Button, wird
                <code>this.state.error</code> wieder auf null gesetzt
              </li>
              <li class="fragment">
                Komponente wird neu gerendert (durch <code>setState</code>). Da
                <code>this.state.error</code> wieder null ist, werden die
                Children erneut gerendert
              </li>
            </ol>
          </div>
        </section>

        <section data-markdown>
          <textarea data-template>
## Zustand (Bibliothek)
<!-- .slide: id="t-zustand" -->
* Leichtgewichtige Bibliothek f√ºr globalen Zustand
* Sehr vereinfacht ausgedr√ºckt eine Art `useState` aber f√ºr globale Daten
* Verglichen mit Redux etwas einfacher. Sowohl was Verwendung, aber auch was Features angeht
---
### Zustand: Stores
* Die Daten werden in Stores gehalten
* Ein Store steht **au√üerhalb** der Komponentenhierarchie
  * Das ist √§hnlich wie z.B. bei Redux
* Wir k√∂nnen aus allen Komponenten direkt darauf zugreifen und die Daten darin ver√§ndern
* Komponenten, die auf den Store zugreifen, werden neu gerendert, wenn sich die Daten darin √§ndern...
  * ...und sie die **ge√§nderten** Daten verwenden
  * das ist anders als beim Context!
  * wir haben also feingranularere Updates
---
### Zustand: Stores
* Ein Store ist ein Objekt, das mit der `create`-Funktion angelegt wird
* An die `create`-Funktion √ºbergibst Du die sog. `initializer`-Funktion.
* Das ist eine Callback-Funktion, die daf√ºr verantwortlich ist, den initialen State zu erzeugen
* Bei der Verwendung mit TypeScript musst Du eine "Currying"-Variante von der `create`-Funktion √ºbergeben, damit du die Typ-Definition setzen kannst
* ```typescript

  type INotificationStore = {
    msg: string|null;
    hide(): void;
    show(msg: string): void
  }

  // Achtung () nach der Typ-Angabe nicht vergessen!
  const useStore = create<INotificationStore>()(
    (set) => ({
      msg: null,

      hide(messageId) {
        set({ msg: null });
      },
      show(msg) {
        set({ msg });
      },
    })
  );
  ```
* Wie wir den Store in unseren Komponenten verwenden, sehen wir in K√ºrze...
---
### Zustand: Stores
* Die `initializer`-Callback-Funktion liefert ein Objekt zur√ºck, dass den initialen Zustand des Stores enth√§lt
* Das Objekt kann sowohl Daten als auch `Actions` (Methoden) enthalten
* Mit den Methoden k√∂nnen Verwender des Stores die darin ver√§ndern
  * Es ist nicht m√∂glich, ohne eine Action die Daten zu ver√§ndern
  * Actions sind aber nicht dazu da, Daten aus dem Store zu _lesen_
* Ein Store ohne Actions ist daher m√∂glich, aber sinnlos:
* ```typescript
  type INotificationStore = {
    msg: string|null;
  }

  const useStore = create<INotificationStore>()(
    (set) => ({
      msg: null,
    })
  );

  // und nu'? Wir k√∂nnen die msg zwar lesen, aber nicht √§ndern...
  ```

---
### Zustand: Actions
* Um die Daten zu ver√§ndern, werden Actions verwendet
* Eine Action ist eine Methode in deinem Store, die von Komponenten aufgerufen werden kann und die ihrerseits neue Daten in den Store setzen kann
* Die Action-Methode kann beliebige Parameter entgegennehmen, so wie es f√ºr dich fachlich sinnvoll ist
* Eine Action-Methode kannst du als `async function` implementieren, wenn Du darin asynchronen Code unterbringen m√∂chtest
* In einer Action-Methode kannst Du beliebige Logik ausf√ºhren
* Um den Store mit neuen Daten zu versorgen, verwendest Du die `set`-Funktion, die an deine `initializer`-Funktion √ºbergeben wird
* ```tsx
  type CounterStore = { count: number; increaseBy(amount: number): void; resetTo(newCount: number): void }

  const counterStore = create<CounterStore>()( set => ({
    // count initial auf 0 setzen
    count: 0,

    resetTo(newCount) {
      set({ count: newCount });
    },

    increaseBy(amount) {
      // number erh√∂hen und in den State setzen
      set(currentState => ({ number: currentState.count + amount }),
    }
  })
  ```
---
### Zustand: set-Funktion
* Die set-Funktion kannst Du auf zwei Arten verwenden:
  1. Du √ºbergibst ihr einen neuen (Teil-Zustand)
  2. Du √ºbergibst ihr eine Callback-Funktion, √ºber die Du Zugriff auf den aktuellen Inhalt des Stores hast
* In beiden F√§llen lieferst du ein neues Objekt zur√ºck. Das neue Objekt wird dann mit dem bestehenden Inhalt deines Stores **gemerged**
* ```typescript
  // Beispiel: Mergen von Zustand
  type EmployeeStore = { name: string; sallary: number; updateSallary(n: number) => void }

  const employeeStore = create<EmployeeStore>()(set => ({
       name: "Klaus", sallary: 30000,
       updateSallary(newSallary: number) {
            // name wird NICHT ver√§ndert, nur sallary neu gesetzt
            set({sallary: newSallary});
       }
  });
  ```
---
### Zustand: set-Funktion
* Mit der Callback-Notation hast Du Zugriff auf die aktuellen Daten deines Stores
* Das ist z.B. n√ºtzlich, wenn Du Daten auf Basis bestehender Werte ver√§ndern m√∂chtest
* Oder zum Beispiel, wenn Du Pr√ºfungen mit den bestehenden Daten durchf√ºhren m√∂chtest
* ```typescript
  type EmployeeStore = { name: string; sallary: number; updateSallary(n: number) => void }

  const employeeStore = create<EmployeeStore>()(set => ({
       name: "Klaus", sallary: 30000,
       updateSallary(newSallary: number) {
            // sallary nur aktualisieren, wenn das neue Gehalt √ºber dem bisherigen liegt
            set(currentState => newSallary > currentState.sallary ? ({ sallary: newSallary }) : {});
       }
    )
  });
  ```
---
### Zustand: get-Funktion
* Um in einer Action auf den aktuellen Store zuzugreifen, gibt es noch eine andere M√∂glichkeit
* An die `initializer`-Funktion wird als zweiten Parameter eine `get`-Funktion geliefert.
* Diese liefert dir ebenfalls den kompletten Store zur√ºck. Dar√ºber kannst Du auch andere Actions ausf√ºhren
* ```typescript
  type EmployeeStore = {
            name: string;
            position: string;
            sallary: number;
            updateSallary(n: number) => void
            promoteToSenior(): void
  }

  const employeeStore = create<EmployeeStore>()( (set, get) => ({
       name: "Klaus", position: "junior", sallary: 30000,

       updateSallary(newSallary: number) {
            // sallary nur aktualisieren, wenn das neue Gehalt √ºber dem bisherigen liegt
            const currentSallary = get().sallary;

            if (newSallary > currentSallary) {
              set({sallary: newSallary });
            }
       },
       promotoToSenior() {
            // Neue Position setzen
            set({ position: "senior" });

            // ggf. Gehalt erh√∂hen
            get().updateSallary(600000);
       }
    )
  });
  ```
---
### Arbeiten mit dem Store
* Die `create`-Funktion liefert eine (Hook-)Funktion zur√ºck, die Du in einer Komponente verwenden kannst, um mit dem Store zu kommunizieren
* Der Hook-Funktion √ºbergibst Du eine Callback-Funktion, die `selector` hei√üt, weil Du damit die Teile aus dem Store ausw√§hlst, die deine Komponente ben√∂tigt
  * Damit kannst Du zwar auch den ganzen Store ausw√§hlen, du solltest aber wirklich immer nur das ausw√§hlen, was Du auch brauchst
  * (√Ñhnlich wie in einer Datenbank, in der Du nur die Spalten einer Tabelle w√§hlst, die du f√ºr deine Aufgabe ben√∂tigst)
* ```typescript
  function SallaryWidget() {
    const sallary = useEmployeeStore( s => s.sallary );
    return <div>Your current sallary: {sallary}</div>
  }
  ```
* In diesem Fall wird die Komponente nur neu gerendert, wenn sich das `sallary` √§ndert.
  * Wenn sich z.B. die `position` √§ndern w√ºrde, wird die Komponente nicht neu gerendert
---
### Arbeiten mit dem Store: Change Detection
* Um zu ermitteln, ob eine Komponente nach √Ñnderungen an einem Store neugerendet werden muss, vergleicht Zustand **die R√ºckgabewerte der Selektor-Funktion**
* Das passiert auf **Referenz-Ebene**.
  * Deswegen musst Du sehr vorsichtig sein, was du zur√ºcklieferst
  * Im Zweifel einfach mehrfach die Hook-Funktion aufrufen und die Daten einzeln ausw√§hlen
* Beispiele:
* ```typescript
  // Komponente wird immer neugerendert, wenn sich das Sallary im Store √§ndern (sonst nicht)
  const sallary = useEmployeeStore(s => s.sallary);

  // Komponente nur neu rendern, wenn Sallary ge√§ndert wird und √ºber 500000 liegt
  // bzw. vorher √ºber 500000 lag und jetzt darunter
  const hasHighSallary = useEmployeeStore( s => s.sallary > 500000 );

  // Komponente wird neu gerendert, wenn sich entwender sallary und/oder exchangeRate ge√§ndert haben
  //  und die Berechnung dadurch einen neuen Wert zur√ºckliefert
  const sallaryInDollar = useEmployeeStore( s => s.sallary * s.exchangeRate );
  ```

---
### Shallow Vergleiche
* Werte, die Du aus dem Store ausw√§hlst werden mit `Object.is` verglichen
  * Das ist im Wesentlichen ein Vergleich von Referenzen
* ```typescript
  const s1 = "a";
  const s2 = "a";
  Object.is(s1, s2); // true

  const n1 = 100;
  const n2 = 100;
  Object.is(n1, n2); // true

  // Achtung bei Objekten und Array!
  const person1 = { firstname: "Klaus" };
  const person2 = { firstname: "Klaus" };
  Object.is(person1, person2); // false
  Object.is(person1, person1); // true

  const cities1 = ["Hamburg", "Berlin"];
  const cities2 = ["Hamburg", "Berlin"];
  Object.is(cities1, cities2); // false
  ```
* Wenn Du **Objekte** oder **Arrays** aus dem Store ausw√§hlst, kann das schnell dazu f√ºhren, dass
            deine Komponente zu h√§ufig neugerendert wird:
* ```typescript
  // Rendert jedesmal (!) wenn sich irgendetwas (!) im Store ver√§ndert,
  // da jedesmal (!) liefert die Selektor-Funktion ein neues (!) Objekt
  // zur√ºck (Object.is ist also immer false)
  const sallaryAndPosition = useEmployeeStore(s => ({ sal: s.sallary, p: s.position )} )
  ```
* Dieses Problem kannst Du auch zwei Arten umgehen
  1. Du kannst [useShallow](https://docs.pmnd.rs/zustand/guides/prevent-rerenders-with-use-shallow) verwenden
  2. Du kannst mehrere Selektoren definieren
---
### Ausw√§hlen mit useShallow
* Mit [useShallow](https://docs.pmnd.rs/zustand/guides/prevent-rerenders-with-use-shallow) f√ºhrt Zustand einen "shallow"-Vergleich durch
* Dann wird nicht die Referenz des zur√ºckgegebenen Objektes verglichen sondern, dessen Eigenschaften/Werte auf oberste Ebene im Objekt/Array
* ```typescript
  // useShallow f√ºhrt zu shallowEqual-Vergleich
  // hier wird s.sallary und s.position jeweils mit Object.is verglichen
  // Nur wenn einer der Aufrufe false ergibt, wird die Komponente neu gerendert
  const sallaryAndPosition = useEmployeeStore(useShallow(s => ({ sal: s.sallary, p: s.position )}));
  ```
* "Nur auf oberste Ebene" bedeutet, dass bei verschachtelten Objekten/Arrays √Ñnderungen unterhalb *nicht* erkannt werden:
* ```typescript
  // Store sieht z.B. so aus:
  const contactStore = {
    address: {
      city: "Hamburg"
    }
    email: "klaus@example.de"
  }

  const address = useContactStore(useShallow(s => ({ address: s.address, email: s.email })));
  ```
---
### Ausw√§hlen mit mehreren Selektoren
* Du kannst das Problem mit Referenzen und `useShallow` umgehen, in dem Du einfach mehrere useStore-Aufrufe verwendest,
            die jeweils primitive Typen ausw√§hlen (bzw. solche Werte, die stabile Referenzen haben, wie actions z.B.)
* ```typescript
  // Diese ausgew√§hlten Werte k√∂nnen alle problemlos und zuverl√§ssig mit "Object.is" verglichen werden:
  const sallary = useEmployeeStore(s => s.sallary);
  const position = useEmployeeStore(s => s.position);
  const promoteToSenior = useEmployeeStore(s => s.promoteToSenior);
  ```            
---
### Arbeiten mit dem Store: Actions ausf√ºhren
* Actions w√§hlst du auf dieselbe Art aus, wie Daten. Es gelten die selben Regeln.
* Dann kannst Du sie wie normale Funktionen in deiner Komponente verwenden
* ```typescript
  function PromoteButton() {
    const isSenior = useEmployeeStore( s => s.position === 'senior' );
    const promoteToSenior = useEmployeeStore( s => s.promoteToSenior );

    return <button disabled={isSenior} onClick={ () => promoteToSenior() }>
            Promote me to senior!
            </button>
  }
  ```
---
## √úbung: Zustand Basics
* *Stelle den `NotificationContext` auf Zustand um*
  * Doku: https://docs.pmnd.rs/zustand/getting-started/introduction
* Bitte arbeite im Verzeichnis `30_zustand_intro/workspace`
  * Dort `npm install` und `npm start` ausf√ºhren (alten npm-Prozess ggf. beenden)
* Der Stand dort entspricht dem "fertigen" Stand aus dem Context-Teil mit fertigem `NotificationContext`
* Stelle `NotificationContext` auf einen Zustand-Store um (Verhalten soll gleich bleiben) und verwende den Store dann in `NotificationApp`
*   TODOs findest Du in `NotificationContext.tsx` und `NotificationApp.tsx`
* Eine L√∂sung findest Du in `material/02_solution_zustand_intro`
* Bei Fragen: fragen üòä
* Wenn Du fertig bist, bitte die Hand heben ‚úã
---
### Konsequenzen bzw. √Ñnderungen gegen√ºber dem Context
* Wir k√∂nnen mit "abgeleiteten" Daten arbeiten, das verhindert Redundanzen
  * `message` z.B. braucht **nicht** mehr im Store zu sein, weil wir jedesmal √ºber `messageId` und `lang` die "fertige" Message ausw√§hlen k√∂nnen
* Wir sparen durch die Selektoren Renderzyklen
* Im Gegensatz zu Context ist der Store immer global.
  * Context kann auch in einer Teil-Hierarchie der Anwendung verwendet werden
  * Das geht mit Zustand zwar auch, aber nur umst√§ndlich: https://docs.pmnd.rs/zustand/guides/initialize-state-with-props
---
### "Berechnete" Daten
* Wir haben bei den Selektoren gesehen, dass Du nicht unbedingt die "Rohdaten" aus dem Store ausw√§hlen musst
* Du kannst auch "berechnete" oder "abgeleitete" Daten ausw√§hlen
* ```typescript
  const isSenior = useEmployeeStore( s => s.position === 'senior' );
  ```
* Damit kannst Du das Rendering deiner Anwendung optimieren (Re-renderings einsparen)
* ü§î Wo macht das in unserem `NotificationStore` Sinn?  ü§î
* ü§î Welche Alternativen gibt es zur Auswahl direkt in einer Komponente? ü§î
* ü§î Wann w√§ren Custom Hooks sinnvoll? ü§î
  * Beispiel: Die `messageId` in unserem Store ist prinzipiell f√ºr jeden einsehbar
  * Das k√∂nnen wir zwar nicht √§ndern, aber mit einem Custom Hook (z.B. `useNotificationMessage`) w√§re es klar(er),
            dass die Message nicht direkt ermittelt werden kann bzw. muss
  * Man k√∂nnte z.B. als Konvention festlegen, dass Daten aus einem Store **immer** nur per Custom Hook ausgew√§hlt werden? ü§î
  * Man k√∂nnte einen Custom Hook bauen, der alle **Actions** eines Stores liefert? Warum? ü§î
---
### Testen von Zustand-Stores
<!-- .slide: id="t-zustand-test" -->
---
### Testen von Zustand-Stores
* Du kannst deine Anwendung wie gewohnt mit Jest/Vitest und Testing Library testen
* Du kannst entweder Komponenten testen, die den Store benutzen oder die Store-Hook-Funktionen oder deine Custom Hook-Funktionen
* ‚ö†Ô∏è Beim Test musst du bedenken: **der Store ist global** und wird **nicht zur√ºckgesetzt *zwischen* einzelnen Tests**!
* ```typescript
  test("01 initial", async () => {
    render(<NotificationApp />);

    // ‚ö†Ô∏è  Initial State: "Keine Notification" sichtbar (messageId: null)
    expect(
      screen.getByRole("heading", { name: /Keine Notification/i }),
    ).toBeInTheDocument();

    await user.click(screen.getByRole("button", { name: /not_found/i }));

    // Im Store ist jetzt messageId auf 'not_found' gesetzt...
  });

  test("02 second", async () => {
    render(<NotificationApp />);

    // ‚ö†Ô∏è  Da der Store nicht zur√ºckgesetzt wird,
    //     ist "Keine Notification" hier NICHT sichtbar,
    //     wenn beide Tests hintereinander ausgef√ºhrt werden, ist dieser Test daher "rot"
    // ‚ö†Ô∏è  Wenn dieser Test einzeln ausgef√ºhrt wird, ist er "gr√ºn", weil der Store
    //     dann den Initial-State hat
    expect(
      screen.getByRole("heading", { name: /Keine Notification/i }),
    ).toBeInTheDocument();
  });
  ```
---
### Testen: Zur√ºcksetzen des States
* Du solltest nach (oder bevor) einem Test den State wieder auf dessen initial Zustand setzen
* Dazu kannst Du die Funktion `getInitialState` verwenden, die auf deinem Store definiert ist
* ```typescript
  act(() =>
    useNotificationStore.setState(useNotificationStore.getInitialState()),
  );
  ```
* Das kannst Du in einer `beforeEach` oder `afterEach`-Funktion machen
* In der Zustand Doku [ist beschrieben](https://docs.pmnd.rs/zustand/guides/testing#setting-up-zustand-for-testing) wie du
            das automatisiert f√ºr *alle* deine Stores nach **allen** Tests automatisch tun kannst
  * Je nach Anwendungsfall w√ºrde ich mich entscheiden, ob sich der Aufwand lohnt, oder man es manuell zur√ºcksetzt
---
### Testen: Manipulieren des States
* Du kannst im Test die Actions deines Stores aufrufen, um die Daten im Store zu √§ndern
* Damit kannst Du das korrekte Verhalten deines Stores √ºberpr√ºfen
* Um Daten au√üerhalb der Actions zu √§ndern, kannst Du die `setState`-Funktion verwenden, die
  auf jedem Store definiert ist
* Damit kannst du √Ñnderungen noch isolierter testen (z.B. ob eine Komponente neu gerendert wird, unabh√§ngig davon, auf welchem Weg die Daten ver√§ndert werden)
* Der `setState`-Funktion √ºbergibst Du eine Untermenge des States.
* Die √ºbergebenen Daten werden mit dem bestehenden State zusammengef√ºhrt (analog zur `set`-Funktion in einer Action)
* ```typescript
  act(() =>
    useNotificationStore.setState({
      lang: "de",
    }),
  );
  ```
* Mit `getState` kannst Du dir jederzeit den aktuellen State abfragen
* Mit `getInitialState` bekommst Du jederzeit den initialen State
* ```typescript
  const currentState = useNotificationState.getState();
  const initialState = useNotificationState.getInitialState();
  ```
* Diese Funktionen stehen dir nat√ºrlich auch au√üerhalb von Tests zur Verf√ºgung.
---
### Testen deiner Hooks
* Den `useXyzStore`-Hook bzw. deine Custom Hooks kannst Du wie gewohnt mit `renderHook` testen
* Auch hier gilt: der Store ist global und du musst ihn nach dem testen zur√ºcksetzen
* ```typescript
  test("01 useMessage test", async () => {
    const { result } = renderHook(() => useNotificationMessage());

    expect(result.current).toBeNull();

    act(() =>
      useNotificationStore.setState({
        messageId: "not_found",
      }),
    );

    // useNotificationMessage liefert die √ºbersetzte Message zur√ºck...
    expect(result.current).toBe("Not found");

    // Sprache √§ndern...
    act(() =>
      useNotificationStore.setState({
        lang: "de",
      }),
    );

    expect(result.current).toBe("Nicht gefunden");

  });

  ```
---
### √úbung: Testen eines Zustand Stores
* *Schreibe Tests f√ºr deinen Store*
* √úberlege dir, was sinnvolle Tests w√§ren
* W√§hle die Teststrategie, die dir am meisten zusagt
  * Du kannst eine Komponente testen, die den Store verwendet
  * und/oder Du kannst die Hooks direkt testen
* In `30_zustand_intro/workspace/src/__test__/` findest Du bereits eine Testdatei, die Du als Vorlage verwenden kannst
* Bei Fragen immer fragen!
* Fertige Tests als "Inspiration" findest Du in `material/05_solution_mit_test`
* Wenn Du fertig bist, bitte die Hand heben ‚úã
  </textarea
          >
        </section>
        <section data-markdown>
          <textarea data-template>
<!-- .slide: id="t-immutability" -->
## Arbeiten mit unver√§nderlichen (immutable) Datenstrukturen
          </textarea>
        </section>
        <section data-markdown>
          <textarea data-template>
### Arbeiten mit unver√§nderlichen (immutable) Datenstrukturen
* <!-- .element: class="demo" -->  40_immutability/workspace/ShoppingCartApp.tsx
  * Schritte in `material/02_demo`:
  1. Item in `ShoppingCart` direkt ver√§ndern
    * Was passiert (nicht) ü§î
    * Warum ist das so? ü§î
  2. `increaseItem` Funktion, die **alle** Items kopiert, aber nur das √ºbergebene incrementiert
    * Updates funktionieren jetzt ‚úÖ
    * Was passiert, wenn `ShoppingCartItem` als `memo`-Komponente gebaut wird?
  3. `increaseItem` kopiert nur noch das ver√§nderte Item
  4. `handleIncrease` wird an `CartItem`-Komponente √ºbergeben
  5. `useCallback` mit `updater`-Funktion f√ºr State
  6. `useMemo` mit einer leeren Liste, einem leeren Objekt o.√§., das direkt in der Komponente erzeugt wird ü§Ø
---
### Arbeiten mit unver√§nderlichen (immutable) Datenstrukturen
* State in React ist grunds√§tzlich **immutable**.
  * Das gilt auch f√ºr Bibliotheken wie Zustand oder Redux.
* Das bedeutet, dass Objekte und Arrays nach dem Erzeugen nicht mehr ver√§ndert werden
  * Das bedeutet auch, dass es problematisch ist, mit ES6 Klassen, Maps und Set im State zu arbeiten
* ü§î **Warum ist das so**?
---
### Arbeiten mit unver√§nderlichen (immutable) Datenstrukturen
* Wenn wir wissen wollen, ob sich Daten ver√§ndert haben:
* **Ohne Immutability:**
  * Es m√ºssen alle Eigenschaften des Objektes bzw. des Arrays *rekursiv* verglichen werden
  * Ist das effizient?
* **Mit Immutability**
  * Die Anwendung muss nur einen Referenz-Vergleich durchf√ºhren
  * z.B. `altesObjekt === neuesObjekt` oder `Object.is(altesObjekt, neuesObjekt)`
  * Das geht sehr schnell!
* Die Annahme ist, dass Objekte/Arrays sehr viel h√§ufiger *verglichen* werden m√ºssen, als dass sie *ver√§ndert* werden
  * Deswegen nimmt man beim √Ñndern potentiell teurere Operationen in Kauf und kopiert die zu √§ndernden Objekte
  * ...und dann ver√§ndert man die Kopie
* Was bedeutet es, wenn wir ein Objekt - wie bei `useShallow` in Zustand - "shallow" vergleichen m√ºssten?
  * <!-- .element: class="demo" --> `40_immutability/workspace/src/shallow-compare.ts`
  * <!-- .element: class="demo" --> `40_immutability/material/10_shallow_compare/__test__` f√ºr fertige Testf√§lle
---
### Native JavaScript-M√∂glichkeiten f√ºr Immutability
          </textarea>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Object Spread Operator</h3>

          <p>
            Mit dem
            <a
              href="https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Operators/Spread_syntax"
              >Spread Operator</a
            >
            k√∂nnen alle Felder eines Objektes an eine andere Stelle kopiert
            werden
          </p>

          <pre class="fragment"><code class="javascript">
            const person = { firstname: "Susi", age: 32 }
          </code></pre>
          <pre class="fragment"><code class="javascript">
            // Kopie erzeugen (herk√∂mmlich)
            const copy = { firstname: person.firstname, age: person.age }

            // copy: { firstname: "Susi", age: 32}
          </code></pre>
          <pre class="fragment"><code class="javascript">
            // Kopie erzeugen (Spread operator)
            const copy = { ...person };

            // copy: { firstname: "Susi", age: 32}

            copy.age = 33;

            person.age; // 32
          </code></pre>

          <pre class="fragment"><code class="javascript">
            const person = { firstname: "Susi", age: 32 }

            const employee = { ...person, salary: 695000 }
            // employee: { firstname: "Susi", age: 32, salary: 695000 }
          </code></pre>
        </section>
        <section>
          <h3 class="fragment">
            Achtung! Object-Spread-Operator kopiert nur "flach"
          </h3>
          <p class="fragment">Beispiel mit Verschachtelung:</p>
          <pre
            class="fragment"
          ><code class="typescript line-numbers" contenteditable data-trim>

const oldPerson = {
  name: "Klaus",

  address: {
    city: "Berlin", country: "Germany"
  }
}
 </code></pre>
          <p class="fragment">
            Was m√ºssen wir tun, wenn Klaus von Berlin nach Hamburg zieht?
          </p>
          <pre
            class="fragment"
          ><code class="typescript line-numbers" contenteditable data-trim>
const newPerson = {
  ...oldPerson, // altes Objekt hier "einf√ºgen"

  // address muss nun auch kopiert werden:
  address: {
    ...oldPerson.address,
    city: "Hamburg"
  }
}
            </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Arbeiten mit immutable Arrays (ES6)</h3>

          <p class="fragment">
            Zum Hinzuf√ºgen von Eintr√§gen zu einem Array immer <b>concat</b> oder
            <b>Spread-Operator</b> benutzen
          </p>
          <p class="fragment">
            <b>push</b> ver√§ndert das bestehende Array, deswegen nicht
            verwenden!
          </p>

          <pre class="fragment"><code class="javascript">
const myArray = [ "a", "b" ];
const extendedArray = myArray.concat( "c", "d" );

             </code></pre>
          <pre class="fragment"><code class="javascript">
        // Spread-Operator bei Arrays

        const oldArray = [ "b", "c" ];

        // Anf√ºgen eines Elementes
        const newArray = [
          "a",  // vorne anf√ºgen
          ...oldArray, // hier altes Array reinkopieren
          "c" // hinten anf√ºgen
        ]

      </code></pre>
        </section>

        <section>
          <h3>Arbeiten mit immutable Arrays (ES6)</h3>
          <p>
            <code>Array.map</code> bildet alle Eintr√§ge aus einem Array auf ein
            neues Array ab
          </p>

          <pre class="fragment"><code class="javascript">
const persons = [
  { lastname: "Mueller", firstname: "Klaus", age: 32 },
  { lastname: "Meier", firstname: "Susi", age: 33 }
]

const olderPersons = persons.map( p => {
  return { ...p, age: p.age + 1 }
})
          </code></pre>
        </section>
        <section>
          <h3>Arbeiten mit immutable Arrays (ES6)</h3>
          <p class="fragment">Eintr√§ge aus Arrays <b>entfernen</b></p>

          <pre class="fragment"><code class="javascript">
        const newArray = oldArray.filter(oldEntry => oldEntry.id === idToBeRemoved);

        // newArray ist eine Kopie ohne die rausgefilterten Eintraege

      </code></pre>

          <h3 class="fragment">Weitere Methoden</h3>
          <p class="fragment">
            Auch die Methode
            <a
              href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice"
              >slice</a
            >
            ver√§ndert das Array nicht, sondern liefert eine Kopie zur√ºck.
          </p>
          <p class="fragment">
            Es gibt eine Reihe neuer Methoden am Array, die ebenfalls immutable
            sind. (Browser-Support pr√ºfen!)
          </p>
          <p class="fragment">
            Zum Beispiel:
            <a
              href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toReversed"
              >toReversed</a
            >,
            <a
              href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toSorted"
              >toSorted</a
            >
            und
            <a
              href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toSpliced"
              >toSpliced</a
            >
          </p>
        </section>

        <section>
          <h3>Arbeiten mit immutable Arrays (ES6)</h3>

          <p class="fragment">Ver√§ndern von Objekten in Arrays</p>

          <pre class="fragment"><code class="javascript">
        // Ver√§ndern von Arrays:

        function changeName(userId, newName) {
          const newArray = oldArray.map(oldEntry => {
            if (oldEntry.id === userId) { // dieses Element soll ver√§ndert werden
              return { ...oldEntry, name: newName }
            }
            return oldEntry; // unver√§ndert
          });

          // newArray ist eine Kopie, mit ggf. ver√§nderten Eintr√§gen
          return newArray;
      }
      </code></pre>
          <p class="fragment">
            Welche Schw√§che hat die oben gezeigte
            <code>changeName</code> Funktion?
          </p>
        </section>
        <section data-markdown="">
          <textarea data-template>
### Arbeiten mit immutable Arrays (ES6)
* Diese Funktion liefert **immer** ein neues Array zur√ºck auch, wenn gar keine Updates durchgef√ºhrt werden (weil `userId` nicht in der Liste
            vorhanden ist, oder der Namen nicht aktualisiert werden muss):
* ```typescript
  const persons = [ id: "U1", name: "Susi", id: "U2", name: "Klaus" ];
  ```
* ```typescript
  const newPersons = changeName("U1", "Susi M√ºller"); // OK
  ```
* ```typescript
  const newPersons = changeName("U3", "Sandra"); // hmmm...
  ```
* ```typescript
  const newPersons = changeName("U2", "Klaus"); // hmmm hmmm...
  ```
* Die Funktion m√ºsste also vorher pr√ºfen, ob das Array √ºberhaupt angepasst werden muss
  * Kannst Du dir vorstellen, wie das bei verschachtelten Strukturen aussieht?
---
### √úbung: Immutability mit plain JavaScript
* Im Verzeichnis `40_immutability/workspace/src` findest Du die Datei `updateShoppingCart.ts`
* Diese Datei enth√§lt eine Funktion, die aber noch nicht implementiert ist üò¢...
* Die Datei enth√§lt aber Anforderungen an die Funktion ü´£
* ...die Du mit JavaScript- bzw. TypeScript-Mitteln umsetzen musst! üò±
* Um zu √úberpr√ºfen, ob deine Implementierung korrekt ist, kannst Du die Tests in `src/__test/updateShoppingCart.test.ts` ausf√ºhren
* Bei Problemen oder Fragen melde dich jederzeit!
* Eine m√∂gliche L√∂sung findest Du in `40_immutability/material/20_es6/solution`
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
<!-- .slide: id="t-immer" -->
## Immutability mit Immer
* F√ºr einfache Operationen stehen eine Reihe guter JavaScript Bordmittel zur Entwicklung von immutable Code zur Verf√ºgung
* Aber bei komplexen √Ñnderungen ist die Arbeit mit nativen JavaScript Mitteln sehr aufwendig und fehleranf√§llig
* Daf√ºr gibt es eine popul√§re Bibliothek: ImmerJs!
---

## Immer f√ºr Arbeiten mit unver√§nderlichen Datenstrukturen

<img src="slides/images/immer.png" />

* [ImmerJs](https://immerjs.github.io/immer/docs/introduction): _Create the next immutable state tree by simply modifying the current tree_
* Konzept: altes Objekt wird in eine Funktion gesteckt, die daraus ein _Draft_ erzeugt
* Das _Draft_ wird mit regul√§ren JavaScript APIs ver√§ndert, als wenn es mutable w√§re
* Immer zeichnet die √Ñnderungen auf
* Zum Schluss werden die √Ñnderungen auf eine Kopie des alten Objektes angewendet

        </textarea
          >
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Immer: produce-Funktion</h3>

          <p>
            Die <b>produce</b>-Funktion bekommt ein Objekt √ºbergeben, sowie eine
            zweite Funktion, die von immer mit einem Draft aufgerufen wird.
          </p>
          <p>
            Dieses Draft kann ver√§ndert werden. Ihr k√∂nnt dort
            <b>alle</b> JavaScript-Funktionen verwenden
          </p>

          <p>
            Der R√ºckgabe-Typ der produce-Funktion ist dann eine Kopie des alten
            Objektes mit den √Ñnderungen, die auf dem Draft vorgenommen wurden.
          </p>

          <pre class="fragment"><code class="javascript">
import produce from "immer";

function changeName(userId, newName) {

  const newArray = produce(oldArray, draft => {
    const oldPerson = draft.find(p => p.id === userId);

    if (oldPerson) {
      oldPerson.name = newName;
    }
  });

  // newArray ist eine Kopie!
  return newArray;
}
            </code></pre>
          <p class="fragment">
            Achtet bitte darauf, dass ihr die √Ñnderungen am Draft vornehmt und
            nicht versehentlich am Original-Objekt!
          </p>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Beispiele: Immer</h3>

          <pre class="fragment"><code class="javascript">
          function handleLastNameChange(newLastName: string) {
              const newUser = produce(user, draft => {
                // draft kann ver√§ndert werden, als ob es ein mutable Objekt sei
                draft.lastName = newLastName;
              })
            );
            setUser(newUser);
          }
        </code></pre>

          <pre class="fragment"><code class="javascript">
          function handleContactTypeChange(contactId: string, newType: string) {
            setUser(
              produce(user, draft => {
                const ix = draft.contacts.findIndex(contact => contact.id === contactId);
                draft.contacts[ix].type = newType;
              })
            );
          }
        </code></pre>
        </section>

        <section data-markdown="">
          <textarea data-template>
### Immer mit React
* Immer ist eine React-unabh√§ngige Bibliothek
* Ihr k√∂nnt sie aber √ºberall in React verwenden, wo ihr mit Daten zu tun habt
  * Bei einfachen Operationen ist es manchmal einfacher, "nur" JavaScript zu Verwenden
  * Ich w√ºrde empfehlen, von Fall zu Fall zu entscheiden, was besser geeignet ist
* F√ºr React `useState` gibt es den [useImmer](https://immerjs.github.io/immer/example-setstate#usestate--immer) Hook
* Dieser hat dieselbe Signatur wie `useState`
* Aber in der **updater**-Funktion wird der aktuelle State als **Draft** √ºbergeben
  * Ihr braucht also die `produce`-Funktion nicht verwenden
* ```typescript
  function PersonList() {
    const [persons, setPersons] = useImmer([ { id: "U1", name: "Klaus" } ]);

    function changeName() {
      setPersons(personsDraft => personsDraft[0].name = "Klaus M√ºller");
    }

    return ...;
  }
  ```
  * Auch hier gilt: von Fall zu Fall entscheiden, ob das sinnvoll ist
  </textarea
          >
        </section>
        <section data-markdown="">
          <textarea data-template>
### √úbung: Immer
* In der vorherigen √úbung haben wir `updateShoppingCart` nur mit JavaScript gebaut.
* Baue nun dieselbe Funktion, aber mit nun mit Immer.
* Du kannst entweder deine bisherige Funktion einfach anpassen,
  * oder Du startest in `40_immutability/workspace/src/updateShoppingCartImmer.ts`
* Auch hier gibt es Tests zur Kontrolle: `src/__test__/updateShoppingCartImmer.test.ts`
  * Da die Fachlichkeit der beiden Implementierung identisch sein soll, sind auch die Tests identisch
* Bei Problemen und Fragen, melde dich.
* Eine L√∂sung findest Du in `40_immutability/material/25_immer/solution`
* Wenn Du fertig bist, bitte Hand heben ‚úã
  </textarea
          >
        </section>
        <section data-markdown="">
          <textarea data-template>
## Zustand, Teil 2
<!-- .slide: id="t-zustand-2" -->
---
### Zustand Middlewares
* Middlewares erlauben euch, euren Store um (technische) Features zu erweitern
* Fertige Middlewares gibt es f√ºr:
  * das Ablegen der Store-Daten in einen Client-seitigen Storage (z.B. Local Storage): https://docs.pmnd.rs/zustand/integrations/persisting-store-data
  * und die Integration von Immer: https://docs.pmnd.rs/zustand/integrations/immer-middleware
* Middlewares sind eine Funktion, die ihr um eure Initializer-Funktion legt
* ```typescript
  import { create } from "zustand";
  import { immer } from "zustand/middleware/immer";

  const useShoppingCartStore = create<ShoppingCartStore>()(
    immer((set, get) => ({
      // ... unver√§ndert ...
    )}
  );
  ```
* Wenn ihr die Immer Middleware verwendet, bekommt ihr in der Setter-Funktion im Store den aktuellen State als Immer **Draft**
* ```typescript
  const useShoppingCartStore = create<ShoppingCartStore>()(
    immer((set, get) => ({
      items: [],
      updateShoppingCart(id, quantity) {
        set(stateDraft => stateDraft.items.find(i => i.id === id).quantity = quantity;
      }
    )}
  );  
  ```
---
### √úbung: Immer Middleware in Zustand
* Wir arbeiten im Verzeichnis `50_zustand_advanced/workspace`
* Dort bitte ggf. `npm install` und dann `npm start` ausf√ºhren
  * (Laufende npm-Prozesse am besten vorher beenden)
* In der Datei `src/stores/shoppingCartSlice` musst Du einen Store f√ºr die `ShoppingCart` implementieren
  * Verwende dabei die `immer`-Middleware. F√ºr die Update-Logik kannst Du deine `updateShoppingCartImmer`-Funktion in leicht modifizierter Variante verwenden.
* In `ShoppingCartApp` musst Du deinen Store dann verwenden (s.h. TODOs dort)
* Bei Fragen oder Problemen melde dich.
* Eine m√∂gliche L√∂sung findest Du in `50_zustand_advanced/material/10_cartStore/10_solution`
* Wenn Du fertig bist, bitte Hand heben in Zoom ‚úã
---
### Feingranulare Updates
* Wir haben bereits einige Techniken gesehen, mit dem Du (unn√∂tige) Renderings unterbinden kannst
* Du kannst auch bei der Auswahl von Daten aus dem Store die Renderings beeinflussen
* Was wird hier wann gerendert? ü§î
* ```typescript
  function ShoppingCart() {
    const items = useShoppingCartStore(s => s.items);
    return items.map(i => <ShoppingCartItem key={i.id} item={i} />)
  }

  function ShoppingCartItem( {item} ) {
    // render ShoppingCartItem
  }
  ```
---
### Feingranulare Updates
* Wenn sich die `items`-Liste im Store √§ndert (aus welchem Grund auch immer, wird die `ShoppingCart` neu gerendert
  * und auch alle `ShoppingCartItem`-Komponenten
* Das K√∂nnen wir mit einer `memo`-Komponente verbessern
* Du kannst an `React.memo` eine Komponente √ºbergeben. `memo` liefert dann eine "memoisierte" (also gecachte) Komponente zur√ºck
* Diese wird nur neu gerendert, wenn sich mind. ein Property ge√§ndert hat (verglichen mit `Object.is`)
* Da unsere `IShoppingCartItem`s immutable sind, w√ºrden dann nur die `ShoppingCartItem`-Komponenten neu gerendert, deren Daten sich auch ge√§ndert haben
* ```typescript
  const ShoppingCartItem = React.memo(function ShoppingCartItem( {item} ) {
    // render ShoppingCartItem
  })
  ```
* K√∂nnen wir noch weiter optimieren?
---
### Feingranulare Updates #2
* Nochmal ein Blick auf die `ShoppingCart`-Komponente üëÄ
* ```typescript
  function ShoppingCart() {
    const items = useShoppingCartStore(s => s.items);
    return items.map(i => <ShoppingCartItem key={i.id} item={i} />)
  }
  ```
* K√∂nnen wir das noch weiter optimieren? ü§î
---
### Feingranulare Updates #2
* Die `ShoppingCart` wird bei jeder kleinsten √Ñnderung an **einem** Item neu gerendert.
* Eigentlich w√ºrde es ausreichen, die `ShoppingCart` neu zu rendern, wenn sich die **Liste** ge√§ndert hat
  * Z.B. die Reihenfolge in der Liste
  * oder wenn Items hinzugekommen oder entfernt worden sind
* Wie k√∂nnten wir das umsetzen? ü§î
---
### Feingranulare Updates #2
* Bei der Arbeit mit vielen globalen State Management System ist es √ºblich, dass die Komponenten weitgehend die Daten ausw√§hlen,
            die sie selbst ben√∂tigen
  * Aber nicht die Daten f√ºr ihre Kind-Elemente
  * Denn das k√∂nnen die Daten des globalen Charakters des State Managements ja selbst tun
* In `ShoppingCart` w√§hlen wir nur noch die **Ids** der darzustellenden Items:
* ```typescript
  function ShoppingCart() {
    const itemIds = useShoppingCartStore(useShallow(s => s.items.map(i => i.id) ) );
    return itemIds.map(id => <ShoppingCartItem key={id} itemId={id} />)
  }
  ```
* Das eigentliche Item w√§hlen wir jetzt in ShoppingCartItem
* ```typescript
  const ShoppingCartItem = memo(function ShoppingCartItem( { itemId } ) {
    const item = useShoppingCartStore(s => s.items.find(i => i.id === itemId) );

    // Item rendern
  })
  ```
---
### Feingranulare Updates #2
* Erinnerung: wir k√∂nnen das noch feingranularer machen
* Wenn `ShoppingCartItem` nicht **alle** Informationen des Items nutzt, w√§hlen wir nur die aus, die wir brauchen
  * Dann werden `ShoppingCart` und vorallem `ShoppingCartItem` tats√§chlich nur gerendert, wenn wirklich notwendig
* ```typescript
  const ShoppingCartItem = memo(function ShoppingCartItem( { itemId } ) {
    // nur name und price w√§hlen
    // wenn sich quantity des Items √§ndern w√ºrde, wird nicht neu gerendert
    const name = useShoppingCartStore(s => s.items.find(i => i.id === itemId).name );
    const price = useShoppingCartStore(s => s.items.find(i => i.id === itemId).price );

    // Alternativ (an useShallow denken!):
    const nameAndPrice = useShoppingCartStore(useShallow(s => {
            const item = s.items.find(i => i.id === itemId);
            return { name: item.name, price: item.price }
    }));

    // name und price rendern
  })
  ```

---
### Render Optimierungen
* Ob und wann solche und andere Optimierungen notwendig sind, h√§ngt von deiner Anwendung und deinen Anforderungen ab
* Wenn man auf stabile Referenzen (Immutability!) achtet, kann man gut zielgerichtet Optimierungen dort vornehmen, wo sie notwendig sind
* Es macht in der Regel wenig Sinn, von vornerein Optimierungen vorzunehmen
  * Oft stellen auch viele Renderings kein Performance-Problem dar
  * Die gezeigten √Ñnderungen haben ja auch Konsequenzen
    * man muss (etwas) mehr Code schreiben
    * `useShallow` und `memo` haben auch Auswirkungen auf Performance und Speicher (Caches sind nicht "umsonst", was Resourcen angeht)
    * Im letzten Beispiel: ist zweimal `find` schneller als `useShallow`? Oder sogar ohne Optimierung?
      * Wie schnell vergessen wir `useShallow` zu verwenden?
    * Pl√∂tzlich hat eine weitere Komponente (`ShoppingCartItem`) eine Abh√§ngigkeit auf den Store, das macht die Tests m√∂glicherweise komplexer
* Zielgerichtet nur dort optimieren, wo wirklich notwendig
  * Bin mir ziemlich sicher, dass in unserem Beispiel die gezeigten Optimierungen √ºberfl√ºssig sind üòú
---
### Zustand: Komplexe Stores
* Grunds√§tzlich k√∂nnt ihr in Zustand mehrere Stores anlegen und verwenden
* Damit k√∂nnt ihr die Daten und Logik fachlich trennen
  * zum Beispiel `ShoppingCartStore` und `UserProfileStore`
* Die Stores sind dann komplett unabh√§ngig von einander
* Aber es gibt nat√ºrlich auch Logik, die sich nicht so einfach trennen l√§sst:
  * Vielleicht haben wir einen Store mit Produkt-Informationen
  * und die ShoppingCart
  * Die Anwendung braucht oft beide Stores (z.B. um den Produktnamen zu einer Produkt-Id zu ermitteln oder den Gesamtpreis im Warenkorb anzuzeigen)
* Fachlich w√§re es hier sowohl sinnvoll, die Stores zu trennen... aber genauso sinnvoll, **einen** Store daraus zu machen
* F√ºr solche F√§lle eignen sich **Slices**
---
### Zustand: Slices
* Ein Slices ist eine Art "Unter-State" oder "Teil-State", der mehr oder minder fachlich abgeschlossen ist
  * Der Begriff kommt urspr√ºnglich aus [Redux](https://redux-toolkit.js.org/usage/usage-guide#creating-slices-of-state)
* Mehrere Slices werden dann zu **einem** Store zusammengef√ºhrt
* ...aber in der Entwicklung k√∂nnen die Slices getrennt entwickelt werden
* Aus Sicht des **Verwenders** ist das **ein** Store
  * das es mehrere Slices sind, ist dann eher ein Implementierungsdetail

---
### Erzeugen eines Slices
* Ein Slice wird √§hnlich erzeugt wie ein Store
  * Du schreibst zun√§chst eine Funktion, die den initialien State des Slices erzeugt und zur√ºckliefert
  * diese Funktion wird `StateCreator` genannt
* Dessen Ergebnis gibst Du zun√§chst aber **nicht** an die `create`-Funktion von Zustand
* ```typescript
  const shoppingCartSlice = (get) => ({
   items: [],
   addItem(productIt) { /* ... */ }
   // ...
  })
  ```
---
### Erzeugen eines Slices: TypeScript
* Die Typsicherheit bzw. die Typ-Angabe ist "etwas" komplex in diesem Fall.
* Es gibt einen Typen `StateCreator`, den Du verwenden kannst. Dieser erwartet gleich vier Typ-Argumente:
  1. Der erste Typ beschreibt den **kompletten** Store mit allen Slices
  2. Der zweite und dritte Typ beschreibt "Modifier"-Funktionen, wie etwa die `immer` Middleware
  3. Der vierte Typ gibt an, wie der State aussieht, mit dem Du in diesem Slice arbeitest
    * Kann identisch mit dem ersten Typen sein, aber auch eine Untermenge dessen
* ```typescript
  type ProductSlice = { products: IProduct[] }
  type ShoppingCartSlice = { items: IShoppingCartItem[], username: string }

  const createProductSlice: StateCreator<
    ProductSlice & ShoppingCartSlice,
    [["zustand/immer", never], never],
    [],
    ProductSlice> =
      (set, get) => ({ /* wie bekannt */ })
  ```
* Ich bin nicht sicher, ob es hier viel Flexibilit√§t gibt, wenn man immer benutzt
* Trotz des einschr√§nkenden vierten Typ-Arguments (`ProductSlice`) haben set- und get
            Zugriff auf den kompletten Store (mit `ShoppingCartSlice`)
* Zur Laufzeit hat man sowieso den ganzen Store
---
### Slices: Den "Bounded Store" erstellen
* Ein "Bounded Store" ist ein Store, der aus mehreren Slices besteht
* Erzeugt wird er mit der bekannten "Curry"-Variante der `create`-Funktion von immer.
* Als Typ-Argument wird hier ein TypeScript-Typ verwendet, der den gesamten Store inkl. aller Slices beschreibt.
* Die `intializer`-Funktion wird hier verwendet, um die einzelnen Slices zu intialisieren:
* ```typescript
  export const useAppStore = create<ProductSlice & ShoppingCartSlice>()(
    immer((...a) => ({
      ...createProductSlice(...a),
      ...createShoppingCardSlice(...a),
    })),
  );
  ```
* Was passiert hier? üôÄ ... üôÄ ... üôÄ
---
### Slices: Den "Bounded Store" erstellen
* So w√ºrden wir zwei separate Stores erzeugen (ohne Slice):
* ```typescript
  function shoppingCartInitializer(set, get) {
    return {
      items: [],
      addItem(id) { set( /* ... */ ) }
    }
  }
  function productInitializer(set, get) {
    return {
      products: [],
      addProduct(id) { set( /* ... */ ) }
    }
  }

  const useShoppingCartStore = create(
    immer(shoppingCartInitializer)
  );
  const useShoppingCartStore = create(
    immer(productInitializer)
  )
  ```
---
### Slices: Den "Bounded Store" erstellen
* Um daraus **einen** Store zu machen (Lang-Version):
* ```typescript
  // initializer unver√§ndert
  function shoppingCartInitializer(set, get) { /* ... */ }
  function productInitializer(set, get) { /* ... */ }

  const useAppStore = create( immer ((get, set) => {

    const productSlice = productInitializer(get, set);
    const shoppingCartSlice = shoppingCartInitializer(get, set);

    return {
      products: productSlice.products,
      addProduct: productSlice.addProduct,
      items: shoppingCartSlice.items
      addItem: shoppingCartSlice.addItem
    }
  })
  ```
* Das Beispiel etwas k√ºrzer:
  *  egal welche Argumente von 'create' unserer Funktion √ºbergeben werden,
  *  wir reichen sie an `immer` und unsere Initializer 1:1 weiter
* ```typescript
  const useAppStore = create( immer ((...a) => {
    const productSlice = productInitializer(...a);
    const shoppingCartSlice = shoppingCartInitializer(...a);
    return { /* ... wie oben ... */ };
  })
  ```
---
### Slices: Den "Bounded Store" erstellen
* ...und in noch k√ºrzer
  * wir verwenden den Spread-Operator, um die Ergebnisse der initializer-Funktionen in das State-Objekt zu "spreaden":
* ```typescript
  const useAppStore = create( immer ((...a) => {
    const productSlice = productInitializer(...a);
    const shoppingCartSlice = shoppingCartInitializer(...a);

    return {
       ...productSlice
       ...shoppingCartSlice
    };
  })
  ```
* ...noch k√ºrzer ist dann nur noch die zuerst gesehene Variante
* ```typescript
  export const useAppStore = create(
    immer((...a) => ({
      ...createProductSlice(...a),
      ...createShoppingCardSlice(...a),
    })),
  );
  ```
* und mit TypeScript geben wir noch den Typ des Gesamtstores an und verwenden die "Curry"-Funktion:
* ```typescript
  export const useAppStore = create<ProductSlice & ShoppingCartSlice>()(
    immer((...a) => ({
      ...createProductSlice(...a),
      ...createShoppingCardSlice(...a),
    })),
  );
  ```
---
### √úbung: ein Bounded Store mit zwei Slices
* Wir arbeiten in `50_zustand_advanced/workspace`
* Kopiere bitte den kompletten Inhalt von `50_zustand_advanced/material/15_slices/00_initial`
  in das `src`-Verzeichnis: `50_zustand_advanced/workspace/src`
  * bestehende Dateien ggf. √ºberschreiben
* In `50_zustand_advanced/workspace` ggf. `npm install` und dann `npm start` ausf√ºhren
  * Noch laufende npm-Prozesse vorher abbrechen
* Aufgaben:
  1. Stelle `useShoppingCartStore` in `shopingCartSlice.ts` auf einen Slice bzw. `StateCreator` um
  2. Erzeuge den "Bounded Store" in `appStore.ts`
  3. Vervollst√§ndige in `ShoppingCartApp.tsx` die `ProductList` und `Product`-Komponenten
* Du findest in allen Dateien auch entsprechende TODOs
* Bei Fragen und Problemen melde dich jederzeit
* Eine m√∂gliche L√∂sung findest Du in `50_zustand_advanced/material/15_slices/10_solution`
* Wenn Du fertig bist, bitte in Zoom die Hand heben ‚úã
---
### "Globale" Actions
* Bislang sind unsere Slices unabh√§ngig voneinander
* Allerdings gibt es im `ProductSlice` die Methode `removeProduct`
* Diese soll ein Produkt entfernen
* ü§î Was tun wir wenn das Produkt auch im `ShoppingCartSlice` schon in einem `ShoppingCartItem` referenziert wird? ü§î
* ü§î Welche M√∂glichkeiten seht ihr, um das entsprechende Item dann auch dem `ShoppingCartSlice` zu entfernen? ü§î
* Wir k√∂nnen Ideen auf dem Miro-Board sammeln
---
### Eine M√∂glichkeit...
* Wir rufen einfach `removeProduct` auf und danach machen wir noch einen Call um auch den `ShoppingCartSlice` zu aktualisieren
* ```typescript
  export function ProductItem( { productId } ) {
    const removeProductFromStore = useAppStore((s) => s.removeProduct);
    const updateItemQuantity = useAppStore((s) => s.updateItemQuantity);

    // Wird beim Klick auf "Dieses Produkt l√∂schen" aufgerufen:
    const handleRemoveProduct = () => {
        removeProductFromStore(productId);
        updateItemQuantity(productId, -100000000); // üôÄ ü´£ 'removeFromCart'-Action w√§re im Store toll...
      }

    return /* ... */
  }
  ```
* Was gef√§llt euch daran (nicht)?
* ```typescript
---
### Eine etwas andere M√∂glichkeit...
* Wir rufen einfach `removeProduct` auf und danach machen wir noch einen Call um auch den `ShoppingCartSlice` zu aktualisieren
* ...dieses mal aber in einem Custom Hook:
* ```typescript
  export function useRemoveProduct() {
    const removeProductFromStore = useAppStore((s) => s.removeProduct);
    const updateItemQuantity = useAppStore((s) => s.updateItemQuantity);

    // Wird beim Klick auf "Dieses Produkt l√∂schen" aufgerufen:
    const removeProduct =
      (productId: string) => {
        removeProductFromStore(productId);
        updateItemQuantity(productId, -100000000); // üôÄ ü´£ 'removeFromCart'-Action w√§re im Store toll...
      }

    return removeProduct
  }

  function ProductItem( {productId} ) {
    const removeProduct = useRemoveProduct();

    return <div>
            { /* ... */ }
            <button onClick={ () => removeProduct(productId) }>Remove</button>
    </div>
  ```
* Ist das besser? Schlechter? Perfekt? Saubl√∂d?
---
### Eine zweite M√∂glichkeit: eine Action im appStore
* Wir k√∂nnen den `appStore` erweitern...
* Der `appStore` hat Zugriff auf beide Slices und kann die Aufgabe √ºbernehmen f√ºr uns
* Das k√∂nnen wir direkt im `appStore` machen oder wir legen einen `appSlice` an,
            der √ºbergreifende Actions enth√§lt
*
* ```typescript
  type AppSlice = {
    removeProductFromStore(productId: string): void;
  };
  const createAppSlice: StateCreator</*...*/> = (set, get) => {
    return {
      removeProductFromStore(productId: string) {
        get().removeProduct(productId);
        get().updateItemQuantity(productId, -100000000); // üôÄ ü´£ 'removeFromCart'-Action w√§re im Store toll...
      },
    };
  };
  ```
* Der `appStore` erh√§lt dann einfach nur einen dritten Slice:
* ```typescript
  export const useAppStore = create<ProductSlice & ShoppingCartSlice & AppSlice>()
  (
    immer((...a) => ({
      ...createProductSlice(...a),
      ...createShoppingCardSlice(...a),
      ...createAppSlice(...a),
    })),
  );
  ```
---
### Eine zweite M√∂glichkeit: eine Action im appStore
* Konsequenzen
  * F√ºr die Anwendung bleibt weiterhin der Store der "Ansprechpartner" (und nicht ein Custom Hook)
  * Der App Store ist die zentrale Stelle, an der unsere Logik implementiert wird
  * Das Update ist nun in jedem Fall atomar
* ü§î Ist die L√∂sung so gut? Was gef√§llt euch besser? ü§î
---
### Eine dritte M√∂glichkeit: die Slices kennen sich!
* Jeder Slice hat immer auch Zugriff auf alle anderen Slices zur Laufzeit
* So kann der `ProductSlice` z.B. in der `removeProduct`-Action eine Action im `ShoppingCartSlice` aufrufen:
* ```typescript
  export const createProductSlice = {
    // alles wie bekannt
  > = (set, get) => ({
    removeProduct(productId: string) {
      // 1. Produkt aus diesem Slice entfernen (wie bekannt):
      set((state) => {
        const ix = state.products.findIndex((p) => p.id === productId);
        state.products.splice(ix, 1);
      });

      // 2. ShoppingCartSlice aktualisieren
      get().updateItemQuantity(productId, -100000000); // üôÄ ü´£ 'removeFromCart'-Action w√§re im Store toll...
    }
    // ...
  });
  ```
* ü§î Wie ist diese Option? ü§î
---
### Globale Actions: Fazit
* Es gibt eine Reihe von M√∂glichkeiten
* Zustand macht keine Aussage dar√ºber, wie wir solche Actions implementieren m√ºssen oder sollen ("unopionated")
* Ich denke, man muss im konkreten Fall schauen
  * Dabei w√ºrde ich darauf achten, dass man nicht zu viele Abh√§ngigkeiten zwischen den Slices hat (wie im letzten Beispiel)
  * wenn man das hat (oft ruft Slice A eine Action in Slice B auf und/oder umgekehrt), vielleicht dar√ºber nachdenken, daraus **einen** Slice zu machen
---
### Struktur des Stores
* K√∂nnen wir die Slices noch anders strukturieren?
* Wie w√§re es mit "Namespaces"?
* ü§î Habt ihr eine Idee? ü§î
* <!-- .element: class="demo" --> Beispiel in `40_namespaces`

---
### √úbung: Eine globale Action
* *Baue eine Action, die ein Produkt aus `ProductSlice` und auch ggf. aus `ShoppingCartSlice` entfernt
* W√§hle bei der Implementierung den Weg, der dir f√ºr diesen Anwendungsfall am besten gef√§llt
* Arbeite in `50_zustand_advanced/workspace` und verwende den bestehenden Store und die bestehenden Slices
  * Du darfst nat√ºrlich alles umbauen, so dass es dir gut gef√§llt
* Bei Fragen und Problemen melde dich gerne.
* Die besprochenen Ans√§tze findest Du fertig implementiert in `50_zustand_advanced/material/20_updates`
---
## Arbeiten mit asynchronen und serverseitigen Daten
<!-- .slide: id="t-async-data" -->

  </textarea
          >
        </section>

        <!-- ============================================================================= -->

        <section data-markdown>
          <textarea data-template>
---
<!-- .slide: id="t-tanstack-query" -->            
# Mordernes Data Fetching in React
---
## Modernes Data Fetching in React
* Mit `useEffect`, `fetch` und `axios` stehen dir "Low-Level-APIs" zur Verf√ºgung, um mit serverseitigen Daten zu arbeiten
* Diese APIs sind React (`useEffect`) bzw. Browser (`fetch`) Standard APIs
* Es gibt aber spezialisierte Bibliotheken, die das Arbeiten mit Daten erleichtern k√∂nnen.
  * [TanStack Query](https://tanstack.com/query/latest) / und [Vercel SWR](https://swr.vercel.app/): Zwei Bibliotheken zum Laden/Speichern von Daten inklusive Cache-Funktion
  * [Redux Toolkit Query](https://redux-toolkit.js.org/rtk-query/overview): Arbeiten mit APIs in Redux-Anwendungen
  * [Apollo GraphQL Client](https://www.apollographql.com/docs/react/): Client f√ºr GraphQL APIs mit Cache und Statemanagement M√∂glichkeiten
* Diese Bibliotheken haben alle √§hnliche Konzepte:
  * Hooks zum Laden/Speichern von Daten
  * globales Caching von Daten (auch zur Sicherstellung der konsistenten Darstellung)
    * Strategien zur Aktualisierung von Daten (auch automatisch im Hintergrund)
---
## TanStack Query
### Schritt-f√ºr-Schritt: Laden von Daten mit "TanStack Query"

* üëâ `PostListPage`
* üëâ sp√§ter: `PostEditorPage`
* üëâ sp√§ter: Custom Hooks 
* üëâ sp√§ter: zod
* üëâ Arbeiten in `advanced/workspace`


---
### Der QueryClient

* Zentrales Konfigurationsobject: `QueryClient`
* React-unabh√§ngig
* Wird beim Starten der Anwendung initialisiert
* Oft reichen Default-Einstellung
* Es k√∂nnen aber z.B. globale Refetch-Policies eingestellt werden
* Das Objekt wird per QueryClientProvider in die Anwendung gereicht
* ```typescript
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: {
        refetchOnWindowFocus: false
      }
    }
  });

  root.render(
    <QueryClientProvider client={queryClient}>
      <App />
    </QueryClientProvider>
  );
  ```

---
### Laden von Daten: useQuery

* [Queries](https://tanstack.com/query/latest/docs/react/guides/queries) werden mit dem `useQuery`-Hook ausgef√ºhrt
* [Der `useQuery`-Hook](https://tanstack.com/query/latest/docs/framework/react/reference/useQuery) erwartet ein Konfigurationsobjekt
  * `queryKey`: Array mit Query Keys (zur Interaktion mit dem Cache)
  * `queryFn`: Funktion zum Laden der Daten
  * Weitere Konfigurationen (optional)
* ```typescript
  import { useQuery } from "react-query";
  import { loadBlogPosts } from "./blog-api";
  function BlogListPage() {

    const result = useQuery({queryKey: ['posts'], queryFn: loadBlogPosts});

    // ...
  }
  ```
---
### Query Function

* `useQuery` erwartet eine [Query-Function](https://tanstack.com/query/latest/docs/react/guides/query-functions), die den eigentlichen Request ausf√ºhrt
* Die Signatur ist fast beliebig, die Funktion muss aber ein Promise zur√ºckliefern:
* Wenn die Daten erfolgreich geladen wurden, muss das Promise mit den Daten "aufgel√∂st" werden
* Wenn es einen Fehler gab, muss die Funktion einen Fehler werfen
* ```typescript
  // async function gibt IMMER ein Promise zur√ºck
  export async function loadBlogPost(postId) {
    const response = await fetch("http://localhost:7000/posts" + postId);

    if (!response.ok) {
      throw new Error("Could not load blog post: " + response.status);
    }

    return response.json();
  }
  ```

---

### R√ºckagebwert von `useQuery` (Query Ergebnis)

* `useQuery` liefert ein Objekt zur√ºck:
  * `isLoading`: Der Query l√§dt noch (und es sind keine Daten im Cache)
  * `isSuccess`: Daten sind geladen
  * `isError`: Es ist ein Fehler aufgetreten
  * `data` enth√§lt die geladenen Daten
  * `error`: Fehlerobjekt aus der Query-Funktion 
* Weitere [siehe Doku](https://tanstack.com/query/latest/docs/react/reference/useQuery)
  
---
### Query Keys

* Mit den [Query Keys](https://tanstack.com/query/latest/docs/react/guides/query-keys) wird ein Ergebnis im Cache gespeichert
* Ein Query Key besteht aus einem Array von Werten
* √úblicherweise ist es ein Name (z.B. "posts") und dann ggf. weitere Parameter, zum Beispiel die Id eines Posts ("P1")
  oder die Sortierreihenfolge
  * Also alle Daten, die den Query exakt beschreiben
* ```typescript
  import { useQuery } from "react-query";
  import { loadBlogPosts } from "./blog-api";

  function BlogPage({blogPostId}) {

    // F√ºr jeden Aufruf mit einer neuen blogPostId
    //  wird das Ergebnis separat in den Cache gelegt
    const result = useQuery({
      queryKey: ['blogPost', blogPostId], 
      queryFn: () => loadPost(blogPostId)
    });

    // ...
  }
  ```
* Wenn ein Query mit denselben Query Keys in mehr als einer Komponente ausgef√ºhrt wird
* stellt TanStack Query sicher, dass der Query nur einmal ausgef√ºhrt wird
* wenn sich das Ergebnis √§ndert, werden alle Komponenten, die den Query verwenden,
automatisch aus dem Cache aktualisiert
* üëâ dieses Verhalten sehen wir uns sp√§ter noch an

---
## √úbung: Daten lesen mit TanStack Query

* Vorbereitung: Backend starten
  * ```bash
  cd 60_tanstack_query/backend
  npm install # falls noch nicht gemacht
  npm start
  ```
  * Danach sollte unter [http://localhost:7000/posts](http://localhost:7000/posts)
* Wir arbeiten in `60_tanstack_query/workspace`
* Dort ggf. `npm install` und dann `npm start` ausf√ºhren (vorherige npm-Prozesse bitte beenden)
* In der Komponente `PostListPage` wird `fetch` bzw. `useEffect` zum Laden der Daten verwendet
* Stelle diese Komponente auf `useQuery` um.
* Zeige eine Warte-Meldung an, w√§hrend die Daten geladen werden
  * Du kannst den Request k√ºnstlich langsam machen, in dem Du an die Url `?slow` h√§ngst
* TanStack Doku: 
  * [Queries](https://tanstack.com/query/v5/docs/framework/react/guides/queries)
  * [useQuery](https://tanstack.com/query/v5/docs/framework/react/reference/useQuery)
* M√∂gliche L√∂sung: `60_tanstack_query/material/10_useQuery`
* Wenn Du fertig bist, bitte die Hand heben ‚úã
---
### Exkurs: Testen von fetch-Aufrufen und asynchronem Code

Herausforderungen:

- Asynchroner Code (nicht beschr√§nkt auf fetch)
- Server Zugriffe/Server Mocks

---

### Behandlung von asynchronem code

---

### Testen von asynchronem Code

Beispiel: Die **PostListPage**-Komponente l√§dt Daten, *erst dann* zeigt sie die DAten ann. Das Laden der Posts ist asynchron.

```javascript
it("should render posts read from backend", () => {
  render(<PostListPage />);

  // Annahme: es gibt einen Artikel mit dem Title "Learning React"
  const articleOne = screen.findByRole("heading", { name: "Learning React" });

  expect(articleOne).toBeInTheDocument(); // THIS WON'T WORK!
});
```

Wir k√∂nnen einen Test als asynchrone Funktion schreiben und darin mit **await** auf ein Element warten

```javascript
// Test-Funktion als async-Funktion (beachte 'async'):
it("should render posts read from backend", async () => {
  render(<PostListPage />);

  // Beachte await hier:
  const articleOne = await screen.findByRole("heading", { name: "Learning React" });

  expect(articleOne).toBeInTheDocument(); // YIPPIE, WORKS
});
```

Achtung! Ihr m√ºsst `find` Query-Funktionen verwenden, da die `get`-Funktionen davon ausgehen, dass ein Element bereits vorhanden ist, und nicht noch darauf warten.

---

### Testen von fetch

Wie gesehen, k√∂nnen wir asynchronen Code testen

Wollen wir "echte" `fetch`-Aufrufe in unserem Code haben, den wir testen?

M√∂glicherweise nicht, weil wir bei echten fetch-Aufrufen auch einen echten, laufenden und funktionierenden Server im Test br√§uchten

Stattdessen wollen wir das "echte" fetch mocken

---

### Fetch mocken, Ansatz #1

Wir k√∂nnen **komplette Module** in Jest mocken

Wir k√∂nnten unseren fetch-Code in ein eigenes Modul schieben und das dann mocken

```javascript
// api.ts (fetch vereinfacht!)
export function readPosts() {
  return fetch("http://localhost:7000/posts").then(response => response.json());
}
```

```javascript
// App.tsx:

import { readPosts } from "./api";
function App() {
  // ...
  React.useEffect(() => {
    // Verwenden von readPosts hier:
    readPosts()
      .then(json => {
        setLoading(false);
        setPosts(json);
      })
      .catch(err => console.error("Loading data failed: " + err));
  }, []);
}
```

---

### Mocken von Modulen in Jest

Es gibt mehrere Varianten. Das hier die einfachste(?)

```javascript
// App.test.tsx

const mockPosts = [
  { id: "1", title: "One Fetch Mock", body: "Lorem ipsum" },
  { id: "2", title: "Second Post Fetch Mock", body: "Some more content" }
];

jest.mock("../api", () => ({
  readPosts: () => Promise.resolve(mockPosts)
}));

it("should render posts read from backend", async () => {
  render(<App />);

  // Hier immer noch asnychroner Code (deswegen await), aber:
  // kein laufender Server mehr ben√∂tigt
  const articleOne = await screen.findByRole("heading", { name: "One" });
  expect(articleOne).toBeInTheDocument();

  expect(screen.getByText("Second Post")).toBeInTheDocument();
});
```

---

### Ansatz #2: fetch API mocken

Es gibt mehrere Bibliothken mit fetch-Mocks

F√ºr mich funktioniert [jest-fetch-mock](https://www.npmjs.com/package/jest-fetch-mock) am Besten

```javascript
// App.test.tsx
it("should render posts read from backend", async () => {
  // setzen des Ergebnisses, das der n√§chste fetch-Aufruf zur√ºckliefern soll
  fetchMock.mockResponse(JSON.stringify(mockPosts));

  render(<App />);

  // Immer noch asynchroner Code, aber kein "echter" fetch-Aufruf mehr,
  // zur√ºckgegeben wird das oben angegebene Ergebnis
  const articleOne = await screen.findByRole("heading", { name: "One Fetch Mock" });

  expect(articleOne).toBeInTheDocument();
});
```

---
### jest-fetch-mock

* `fetchMock.mockResponse`: Ersetzt *alle* Aufrufe mit dem √ºbergebenen Ergebnis
* `fetchMock.mockResponseOnce`: Ersetzt nur den n√§chsten Aufruf mit dem √ºbergebenen Ergebnis
* `fetchMock.mockResponses`: Ersetzt die n√§chsten X Aufrufe mit den √ºbergebenen Ergebnissen
* Alle Funktionen haben dieselbe Signatur:
  * Entweder ihr setzt direkt das Ergebnis, das zur√ºckgeliefert werden soll
  * Oder ihr gebt eine Callback-Funktion an, die ein `Promise` mit der gew√ºnschten Ergebnis zur√ºckliefert
* Wenn ihr das Ergebnis direkt setzt, k√∂nnt ihr zwei Parameter √ºbergeben:
  1. Den Body, der zur√ºckgeliefert werden soll Achtung! String kein Objekt! (ggf.`JSON.stringify()` verwenden)
  2. Ein Objekt mit init-Parametern, mit dem ihr z.B. den Status setzen k√∂nnt
  * siehe dazu [API Dokumentation der Response Funktion](https://developer.mozilla.org/en-US/docs/Web/API/Response/Response)
* ```
  const mockPosts = [ { title: "Hello", body: "World"} ];
  // liefert HTTP 200 OK zur√ºck f√ºr alle folgenden fetch-Aufrufe zur√ºck:
  fetchMock.mockResponse(JSON.stringify(mockPosts));
  ```
* ```
const mockResponse = { id: "100", title: "Hello", body: "World", createdAt: "2022-09-06"};
// liefert HTTP 201 CREATED f√ºr den n√§chsten fetch-Aufrufe zur√ºck:
fetchMock.mockResponse(JSON.stringify(mockResponse), { status: 201 });
```
---
### Alternative: nock
* [Nock](https://github.com/nock/nock) mockt ebenfalls `fetch`-Aufrufe analog zu jest-fetch-mock
* Die API zum beschreiben des Mock-Verhaltens ist hier aber sehr viel m√§chtiger
* Es gibt aber Probleme mit dem nativen `fetch` in neueren Node.js-Versionen
  * nock funktioniert damit nur mit einer Beta-Version
  * In unserem Setup hier habe ich aber auch die Beta-Version nicht ans Laufen bekommen
* ```typescript
  // in meiner Testdatei:
  const nock = require('nock')

  const scope = nock('http://localhost:7000')
    .get('/posts')
    .reply(200, mockPosts);

  // Test dann unver√§ndert
  ```
---
### Alternative: Mock Service Worker
* **Mock Service Worker** ([MSW](https://github.com/mswjs/msw))
* ...verwendet [Service Worker](https://developer.mozilla.org/de/docs/Web/API/Service_Worker_API), um Netzwerk-Requests zu mocken
* Dadurch werden `fetch`-Aufrufe noch ausgef√ºhrt, aber nicht vom "echten" Netzwerk beantwortet, sondern vom gemockten
* ```typescript
  // PostList.test.tsx
  import { rest } from 'msw'
  import { setupServer } from 'msw/node'

  const server = setupServer(
    rest.get('/posts', (req, res, ctx) => {
      return res(ctx.json( mockPosts ))
    }),
  )

  test("it should render blog list", async () => {
    render(&lt;PostList />);

    // alles weitere wie gesehen...
  })
  ```
* Mock Service Worker bieten die realistischsten Tests, weil am wenigsten Code gemockt wird
---
### End-to-End Browser Tests
* Hier wird die zu testende Anwendung gestartet und dann ein Browser "ferngesteuert"
* Diese Tests sind oft aufw√§ndig zu schreiben (und vor allem: zu warten) und verglichen mit den anderen Ans√§tzen langsamer
* Aber: sie bieten eine hohe Sicherheit, denn wir testen die echte, komplette Anwendung im Browser
* **H√§ufig eingesetzt:**
  * [Selenium](https://www.selenium.dev/): der Klassiker, gibt's schon lange, f√ºr alle Programmiersprachen. API ist m.E. umst√§ndlich.
  * [Cypress](https://www.cypress.io/) und [TestCafe](https://testcafe.io/): Leichtgewichtige Alternativen zu Selenium. Funktionieren technisch etwas anders, weniger "low-level". Tests werden entweder aufgezeichnet und/oder in JavaScript bzw. TypeScript geschrieben.
  * [Playwright](https://playwright.dev/): Browser-Test-Framework von Microsoft f√ºr unterschiedliche Sprachen (u.a. TypeScript und Java). Vergleichsweise schnelle Ausf√ºhrung, guter Support f√ºr diverse Browser. Hype-Kurve extrem steil zurzeit.
  * Sowohl Cypress, TestCafe als auch Playwright bieten gute Features zum Debuggen der Tests und auch gute Reports (samt Videos und Screenshots von der Durchf√ºhrung des Tests) im Fehlerfalle.
  * Alle Tools lassen sich in einer CI/CD-Pipeline ausf√ºhren.
---
### TanStack Query: Mutations

* [Mutations](https://tanstack.com/query/latest/docs/framework/react/guides/mutations) werden verwendet, um Daten zu *ver√§ndern* (speichern, l√∂schen)
* Der entsprechende Hook hei√üt [`useMutation`](https://tanstack.com/query/latest/docs/framework/react/reference/useMutation)
* Dessen API ist vergleichbar mit `useQuery`
* Auch der `useMutation`-Hook liefert Informationen √ºber den Zustand der Mutation zur√ºck
* ```typescript
  import { useMutation } from "react-query";
  import { savePost } from "./blog-api";

  function PostEditorPage() {
    const mutation = useMutation({
      mutationFn: savePost,
      onSuccess() {
        // optional: wird aufgerufen, wenn die Mutation erfolgreich war
        // ...
      }
    });

    if (mutation.status === "error") {
      return <h1>Error!</h1>;
    }

    if (mutation.status === "loading") {
      return <h1>Saving, please wait!</h1>;
    }

    // ...
  }
  ```
---
### TanStack Query: Mutations  
* Im Gegensatz zu `useQuery` wird eine Mutation aber nicht automatisch ausgef√ºhrt, sondern wird explizit gestartet
* Dazu liefert `useMutation` die Funktion `mutate` zur√ºck
* √úbergeben wird der Funktion die zu schreibenden Daten
* ```typescript
  const mutation = useMutation(/* ... */ );

  function saveBlogPost(newPost: NewBlogPost) {
    mutation.mutate(newPost);
  }
  ```
---
### Parameter f√ºr die Mutations
* √úblicherweise ben√∂tigt eine Mutation Daten, die erst bei der Ausf√ºhrung `mutate` feststehen
* Dazu kann der `mutate`-Funktion genau **ein** Parameter √ºbergeben werden
* Wie dieser aussieht bestimmt ihr in der Definition der Mutation selbst
* Dieser Parameter entspricht n√§mlich dem ersten Parameter der `mutationFn`:
  * ```typescript
    const addPostMutation = useMutation({
      mutationFn(newBlogPost: NewBlogPost) { /* ... */ }
    })
    ```
* Wenn ihr mehr als einen "logischen" Parameter ben√∂tigt, m√ºsst ihr ein Objekt verwenden:
* ```typescript
  type AddCommentParam = { postId: string, comment: string };

  const addCommentMutation = useMutation({
    mutationFn(param: AddCommentParam) {
      const url = `/api/posts/${postId}/comments;
      fetch(url, { 
        body: JSON.stringify({comment: param.comment})
      });
    }
  });
  ```

---
### Arbeiten mit dem Ergebnis

* Wenn eine Mutation ausgef√ºhrt wurde, bekommt ihr `data` bzw. `error` zur√ºck
* Damit k√∂nnt ihr - wie bei `useQuery` - nach der Ausf√ºhrung einer Mutation die UI aktualisieren, um zum Beispiel Fehlermeldungen anzuzeigen
* ```typescript
  function PostEditor() {
    const savePostMutation = useMutation(/*...*/);

    return <form>
      { /* ... */}

      {saveMutation.isError && <p>Fehler beim Speichern des Posts: {String(saveMutation.error)}</p>}
      {saveMutation.isSuccess && <p>Der Blogpost wurde erfolgreich gespeichert!</p>}
    </form>
  }
  ```
---
### Auf das Ergebnis warten
* Um direkt nach Beendingung einer Mutation weitere Aktionen auszuf√ºhren, kann man `on`-Callback-Funktionen bzw. [`mutateAsync`](https://tanstack.com/query/latest/docs/framework/react/guides/mutations#promises) verwenden
* `onSuccess` und `onFailure` k√∂nnt ihr bei `useMutation` angeben. Das ist sinnvoll f√ºr Aktionen, die immer ausgef√ºhrt werden sollen
  * Sehen wir sp√§ter noch im Zusammenhang mit Caching.
* Mit `mutateAsync` k√∂nnt ihr _in einer Komponente_ auf das Ergebnis der Mutation warten. Das ist sinnvoll, wenn man Komponenten-spezfische Aktionen ausf√ºhren m√∂chte.
* `mutateAsync` liefert ein Promise mit den Daten der Mutation zur√ºck.
* Schl√§gt die Mutation fehl, wird das Promise nicht verworfen (rejected)
* Beispiel:
* ```typescript
  function PostEditor() {
    const navigate = useNavigate(); // vom React Router

    const savePostMutation = useMutation({ /* ... */ });

    async function savePost(newPost: NewPost) {
      const result = await savePostMutation.mutate(newPost);
      // result ist hier das Ergebnis der (erfolgreichen) Mutation

      navigate("/"); // nach erfolgreicher Mutation zur√ºck auf die Landingpage
    }

    // ...

  }
  ```


---
### Zur√ºcksetzen einer Mutation

* Wenn eine Mutation ausgef√ºhrt wurde, ist `status`, `data`, `error` usw. gesetzt
* Mit `reset` kann man diese Informationen zur√ºcksetzen
* Das kann zum Beispiel nach einem Fehler sinnvoll sein, um die Fehlermeldung wieder verschwinden zu lassen
  * Zum Beispiel nach einer Benutzer-Interaktion
* Dann ist die Mutation "wie neu"
* ```typescript
  function PostEditor() {
    const addPostMutation = useMutation(/* ... */);

    return <form>
      { /* ... */ }

      <input onChange={e => {
        addPostMutaton.reset();
        // ...
      }} />

      { /* ... */ }
    </form>
  }
  ```



---
## √úbung: Neue Blogposts auf den Server schreiben

* Die `PostEditor`-Komponente verwendet noch `fetch` um den neuen BlogPost zu speichern
* Stelle die Komponente auf TanStack Query bzw. den `useMutation`-Hook um
* Wenn die Mutation erfolgreich war und der Blogpost gespeichert wurde, soll die Landing-Page (`/`) gerendert werden
  * Das entspricht dem bisherigen Verhalten, der Code mit `useNavigate()/navigate` ist bereits in der Komponente
  * Der neue Post wird dort erst nach einem manuellen Refresh der Seite angezeigt. Das optimieren wir sp√§ter.
* Optional: Wenn es einen Fehler gibt, soll eine Fehlermeldung ausgegeben werden
  * Du kannst Fehler beim Speichern provozieren, in dem Du einen Titel eingibst, der k√ºrzer als f√ºnf Zeichen lang ist
* Optional: Wenn es einen Fehler gab und der Benutzer danach etwas in eines der Textfelder eingibt, soll die Fehlermeldung wieder verschwinden
* M√∂gliche L√∂sung `material/20_useMutation`
---
## Custom Hooks
* Custom Hooks sind "normale" JavaScript/TypeScript-Funktionen, die aber andere (React-) Hooks (z.B. `useState`) verwenden k√∂nnen
* Custom Hooks k√∂nnen f√ºr Code verwendet werden, der wiederverwendet werden soll
* Der Name einer Hook-Funktion muss mit `use` anfangen
* Die Signatur einer Hook-Funktion (R√ºckgabe-Wert und Parameter) kannst du frei w√§hlen. 
  * Allerdings d√ºrfen Hook-Funktionen nicht asynchron sind
---
### Custom Hooks mit TanStack Query
* Wenn Du einen Query in mehreren Komponenten verwenden willst, kannst Du dessen Code in Custom Hooks auslagern
* Selbst wenn du einen Query nur in einer Komponente verwendest, kann es sinnvoll sein, diesen auszulagern:
  * Man kann ihn insoliert testen
  * Der "technische" Code der Komponente wird verringert, was evtl. zu besserer lesbarkeit f√ºhrt

* ```typescript
  function useBlogListQuery() {
    return useQuery({ /* ... */ });
  }

  function PostListPage() {
    const result = useBlogListQuery();
  }

  function App() {
    const result = useBlogListQuery();
  }
  ```
---
## √úbung: Ein Custom Hook zum Laden eines einzelnen Blog-Post
* In der `PostPage` soll der gew√§hlte Post mit einem Query geladen werden.
* Au√üerdem soll (neu!) in der Sidebar der Post mit der Id `P10` geladen und angezeigt werden
* Kannst du einen eigenen Hook bauen, der den BlogPost mit einer angegebene Id l√§dt?
  * Den `fetch`-Code f√ºr die `queryFn` kannst Du aus `PostPage` √ºbernehmen
* Stelle dann `PostPage` um, so dass diese Komponente deinen Hook verwendet
* Verwende dann deinen Hook um in `Sidebar` das Blog-Post mit Id `P10` zu laden und daraus `title` und `likes` anzuzeigen
* L√∂sung: `material/30_custom_hook`
  
---
## Validieren von Daten

---
### Validieren von Daten
* <!-- .element: class="demo" --> Au√üerhalb des Projektes, in einer TypeScript-Datei:
* <!-- .element: class="demo" --> fetch-Ergebnis ist any in TypeScript
* <!-- .element: class="demo" --> zod
---
### Validieren von Daten
<!-- .slide: class="left" -->
- Das Ergebnis eines `fetch`-Calls ist aus TypeScript-Sicht ein Promise von `any`
- Wir k√∂nnen das Ergebnis also verwenden, ohne weitere Typ-Angaben zu verwenden:
* ```typescript
  async function loadPost(postId: string) {
    const response = await fetch("...");
    const data = await response.json();
    //      ^-- data ist 'any'
    return data;
  }
  ```
- Mit `data` bzw. dem R√ºckgabewert von loadPost k√∂nnen wir alles machen - unabh√§ngig davon, ob das richtig ist oder nicht:
* ```typescript
  const data = await loadPost("P10");
  const title = data.title; // wahrscheinlich ok, weil title in blog post vorhanden ist
  const blogPost = data[2]; // wahrscheinlich nicht ok, weil data kein Array ist
  const title = data.toUpperCase(); // wahrscheinlich nicht ok, weil data kein string ist
  ```
* Wir haben hier keinen Support von TypeScript!  
---
### Validieren
<!-- .slide: class="left" -->
* Wir k√∂nnen einen Typecast verwenden, um TypeScript den R√ºckgabe-Typen mitzuteilen:
* ```typescript
  async function loadPost(postId: string): Promise<BlogPost> {
    const response = await fetch("...");
    const data = await response.json();
    //      ^-- data ist 'any'
    return data as BlogPost;
    //          ^--  Typecast
  }
  ```
* Ist das gut? Welche Probleme k√∂nnte es nun geben? ü§î
---
### Typecast vs. Validierung
<!-- .slide: class="left" -->
- Mit einem Typecast sagen wir TypeScript welchen Typ eine Variablen haben soll
* Das kann richtig oder falsch sein:
* ```typescript
  const s:string = "Hallo";
  let y:any = s;
  let x:number = y as number; üôÄ
  ```
- In unserem Beispiel sind wir uns sicher, dass `data` ein `BlogPost`-Objekt ist.
* Oder? ü§î
---
### Validierung
<!-- .slide: class="left" -->
* Die Daten, die von einem Server (oder auch aus Benutzereingaben) kommen, k√∂nnen von TypeScript nicht √ºberpr√ºft werden
* TypeScript ist zu Laufzeit "weg"
* Wenn der Server also Daten schickt die - entgegen unserer Erwartung - nicht zu dem passen, was wir als TypeScript-Typ definiert haben, merken wir das nicht
  * (abgesehen davon, dass die Anwendung irgendwann in Fehler l√§uft)
* Besser w√§re bei solchen Daten eine echte Laufzeit-Validierung
* Dabei werden die gelesen Daten nach dem Empfang √ºberpr√ºft:
* ```typescript
  async function loadPost(postId: string): Promise<BlogPost> {
    const response = await fetch("...");
    const data = await response.json();
    if (typeof data !== "object") {
      // Fehler!
    }
    if (!"title" in data) { /* Fehler! */ }
    if (!"body" in data) { /* Fehler! */ }
    // ...
    // ok: data ziemlich sicher BlogPost
    return data as BlogPost;
  }
  ```
* Ist das sch√∂n?
---
### Probleme mit manueller Validierung

* Validierung kann viel Code in Anspruch nehmen
* Au√üerdem redundant: 
  * wir m√ºssen den Code zur Validierung schreiben (Laufzeit)
  * wir m√ºssten den TypeScript-Code schreiben (Buildzeit)
---
### Validierungsbibliothek: zod
<!-- .slide: class="left" -->
- Mit [zod](https://zod.dev) gibt es eine Validierungsbibliothek, die beides verbindet
- Mit (JavaScript)-Code, der auch zur Laufzeit ausgef√ºhrt wird, wird ein **Schema** beschrieben
- Dieses Schema kann zur Laufzeit verwendet werden, um ein beliebiges Objekt zu validieren
- Au√üerdem kann aus dem Schema ein TypeScript-Type f√ºr die Build-Zeit abgeleitet werden
* ```typescript
  import { z } from "zod";

  const UserSchema = z.object({
    username: z.string(),
    email: z.email(),
    nickname: z.string().nullish()
  });
  ```
---
### Zod
* Mit dem `z`-Objekt lassen sich Typen (einfache und komplexe) beschreiben
* Objekte werden mit [`z.object`](https://zod.dev/?id=objects) beschrieben
* Dabei kann man nicht nur Typen angeben ([`string`, `number`](https://zod.dev/?id=primitives), `email`, ....) sondern auch Wertebeschr√§nkungen
  * [Mindestl√§nge, Maximall√§nge](https://zod.dev/?id=minmaxlength), erlaubte Zeichen etc.
* Mit der [`parse`-Methode](https://zod.dev/?id=parse) am `Schema`-Objekt kann dann ein beliebiges Objekt validiert werden.
* Wenn das Objekt nicht dem Schema entspricht, wird ein Fehler geworfen
* Wenn alles in Ordnung ist, kommt das validierte Objekt zur√ºck
* ```typescript
  const potentialUser = await loadUser("U1");

  const user = UserSchema.parse(potentialUser);
  ```
* Dadurch ist auch TypeScript der Typ bekannt!
* ```typescript
  type User = { username: string; email: string; nickname?: string | null };
  const user: User = UserSchema.parse(potentialUser);
                     // ^--- ok
  
  ```
* üëâ Zod ist nicht React-spezifisch, das k√∂nnt ihr aber in React verwenden
  * auch mit Zustand, React Hook Form und anderen Bibliotheken, in denen ihr "nicht vertrauensw√ºrdige" Daten habt.
---
### Zod: Ableiten des TypeScript-Typen  
* Den TypeScript-Typen m√ºssen wir gar nicht selber schreiben, dass kan zod f√ºr uns machen:
* ```typescript
  export const UserSchema = z.object({ /* ... */ });
  export type User = z.infer<typeof UserSchema>
  ```
---
### √úbung: zod

* Erweitere deinen Custom-Hook zum Laden eines BlogPosts um die Validierung mit zod!
* Definiere das Schema des BlogPost-Objektes (als Vorlage soll der fertige `BlogPost`-Type in `types.ts` dienen)
* Das `title`-Feld soll eine Maximall√§nge von 40 Zeichen haben.
* Das `likes`-Feld muss optional sein!
* Nach dem Laden der Daten mit TanStack Query soll das geladenen Objekt dann validiert werden
  * Wenn Du den Post "Something to remember when learning new tech" (ID: "P5") √∂ffnest, sollte eine Fehlermeldung erscheinen, weil dessen Titel l√§nger als 40 Zeichen ist
  * Das dauert eine Zeit, weil TanStack Query bei einem Fehler automatisch mehrere weitere versuche unternimmt, die Daten zu laden
  * Erst danach wird dann die Fehlermeldung gerendert
* L√∂sung: `material/32_zod`



---
### Caching

* Alle gelesenen Daten werden in einem globalen Cache gehalten
* üëâ Dev Tools!
* Es gibt verschiedene Strategien, wie die Daten im Cache aktualisiert werden

---
### (Automatisches) Aktualisieren von Daten

* Alle Query-Ergebnisse von `useQuery` werden automatisch gecached
* Alle Komponenten werden aktualisiert, wenn sich der Cache aktualisiert
* Alle Daten im Cache werden als "stale" (veraltet) angesehen
* [Per Default](https://tanstack.com/query/latest/docs/react/guides/important-defaults) werden Queries deswegen automatisch neu ausgef√ºhrt:
* Komponente wird (neu) gemounted
* Browser-Fenster bekommt den Focus
* Nachdem das Netzwerk offline war

---

### Manuelles Aktualisieren von Queries

* Queries k√∂nnen per API manuell erneut ausgef√ºhrt werden
* Das kann zum Beispiel nach einer Mutation sinnvoll sein, um die ge√§nderten/gespeicherten Daten 
im Cache zu aktualisieren
* Dazu wird die Funktion [`invalidateQueries`](https://tanstack.com/query/latest/docs/react/reference/QueryClient#queryclientinvalidatequeries) vom `QueryClient` verwendet
* √úbergeben werden die Query Keys, deren Queries erneut ausgef√ºhrt werden sollen
* ```typescript
  import { useMutation, useQueryClient } from "react-query";
  import { savePost } from "./blog-api";

  function PostEditorPage() {
    const queryClient = useQueryClient();
    const mutation = useMutation({
      mutationFn: savePost, 
      onSuccess() {
        // PostPage-Query erneut ausf√ºhren, wenn Mutation erfolgreich war
        queryClient.invalidateQueries(['posts']);
      }
    });

    // ...
  }
  ```

---

### Beispiel: Blog-Post nicht neuladen

* Ein einzelnes BlogPost kann im Cache verbleiben, da es sich in unserer App nicht √§ndert/nicht √§ndern kann
* Mit den `refetch`-Funktionen kann die automatische Aktualisierung ausgeschaltet werden
* ```typescript
  function PostPage() {
    // ...
    const result = useQuery({queryKey: ["blogPost", postId], queryFn: () => loadBlogPost(postId)}, {
      refetchOnMount: false,
      refetchOnWindowFocus: false
    });  

    // ...
  }
  ```

---

### Refetch

* Das von `useQuery` zur√ºckgeliefert Objekt enth√§lt auch eine `refetch`-Funktion um einen Query
manuell neu auszuf√ºhren
* ```typescript
  function PostListPage() {
    const result = useQuery({queryKey: ['posts'], queryFn: readPosts}, {
      // nicht automatisch aktualisieren
      refetchOnMount: false, refetchOnWindowFocus: false
    })

    // ... result.status === loading, status === error ... 

    return <div>
      <button onClick={refetch}>Reload Posts</button>
      <PostList posts={data} />
    </div>
  }
  ```
---
## √úbung: Arbeiten mit dem Cache
* In der `Sidebar` und/oder `Post`-Komponente soll ein Blog-Post "geliked" werden k√∂nnen
* Kopiere dazu die Datei `material/use-like-mutation.ts` in dein `src`-Verzeichnis
* Darin ist eine Mutation die f√ºr ein angegebenen Blog Post einen "Like" vergibt
* F√ºge in der `Sidebar` einen "Like"-Button hinzu, der die Mutation verwendet
* Stelle sicher, dass die neue "Like"-Anzahl sowohl in der `BlogPost`- als auch in der `Sidebar`-Komponente korrekt dargestellt wird
  * mit einem reload-Button, mit `invalidateQueries` mit `onSuccess` oder wie auch immer
* L√∂sung: `steps/34_caching_mutation`


---
## Suspense
<!-- .slide: id="t-suspense" -->

* Suspense ist ein relativ neuer Mechanismus in React, um das Arbeiten mit asynchronem Code (insb. Data Fetching) zu vereinfachen
* Suspense unterbricht das Rendern, wenn eine Komponente wegen noch fehlender Daten nicht gerendert werden kann
  * Daten k√∂nnen "normale" Daten sein, die z.B. mit TanStack Query geladen werden
  * ...oder Source-Code, der mit Lazy Loading erst bei Bedarf nachgeladen wird
---
### Suspense f√ºr Lazy-Loading
* Suspense f√ºr Lazy-Loading/Code Splitting gibt es schon l√§nger als stabiles Feature in React
* Bei Lazy Loading wird der Code f√ºr eine Komponente erst geladen, wenn er ben√∂tigt wird
* ```typescript
  import { lazy } from 'react';

  
  const PostEditor = lazy(() => import('./PostEditor'));
  ```
* Der Source-Code f√ºr `PostEditor` wird vom Browser erst geladen, wenn die Komponente ben√∂tigt bzw. verwendet wird
* W√§hrend der Source-Code geladen wird, muss React einen Platzhalter anzeigen
* Dazu kann um eine Komponente die `Suspense`-Komponente von React gelegt werden
* ```typescript
  const PostEditor = lazy(() => import('./PostEditor'));
  
  function PostEditorPage() {
    // ...
  
    return  <React.Suspense> fallback={"Please wait"}>
      <PostEditor />
    </React.Suspense>;
  }
  ```
* Hier w√ºrde React zun√§chst die `fallback`-Komponente (`Please wait`) rendern und darstellen, bis der Source-Code f√ºr `PostEditor` geladen wurde
* Danach rendert React die Komponente (`PostEditorPage`) erneut und kann nun den `PostEditor` darstellen.

---
### Suspense f√ºr Daten ("Suspense for Data Fetching")
* Um Suspense mit fetch o.√§. zu verwenden, muss die eingesetzte Bibliothek Suspense unterst√ºtzen
  * Das k√∂nnen wir in unserem eigenen Code nicht machen
  * TanStack Query, React Router und der Apollo GraphQL Client unterst√ºtzen Suspense in ihren neusten Versionen
---
### Suspense mit TanStack Query 

* Die Verwendung mit TanStack Query ist denkbar einfach: ihr verwendet den `useSuspenseQuery`-Hook statt des `useQuery`-Hooks
* Die Parameter sind dieselben
* Aber: der Query liefert erst ein Ergebnis, wenn die Daten geladen worden sind (oder im Cache vorhanden sind)
  * F√ºr die Dauer der Ladezeit muss `Suspense` verwendet werden, um eine Platzhalter-Komponente zu rendern
  * F√ºr den Fall eines Fehlers muss eine [Error-Boundary-Komponente](https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary) gesetzt werden
    * Das ist eine Art try-catch-Mechanismus, mit dem eine React-Anwendung auf Fehler _w√§hrend des Renderns_ reagieren kann

* ```typescript
  function Post({postId}) {
    // hier wird das Rendern von React unterbrochen, bis die Daten da sind:
    const data = useSuspenseQuery({queryFn: fetch(/*...*/), queryKey: ["post", postId] });
    // wenn die Anwendung hierher kommt, sind die Daten in jedem Fall vorhanden
    return ...;
  }

  function PostPage() {
    return (
      <ErrorBoundary fallback={<h1>Loading failed!</h1>}>      
        <Suspense fallback={<h1>Post P10 loading...</h1>}>
          <Post postId="P10" />
        </Suspense>
      </ErrorBoundary>
    )
  }
  ```
---
### Error Boundary
- Eine Error Boundary-Komponente kann man grunds√§tzlich selbst bauen
- Fehler, die beim Rendern unterhalb einer Error-Boundary-Komponente auftreten, werden als eine Art Propertie in die n√§chsth√∂here Error-Boundary-Komponente gegeben
  - √§hnlich wie try/catch
- Die Komponente kann dann eine Fehlermeldung o.√§. rendern  
- Ihr k√∂nnt damit sehr feingranular steuern, wo Fehler angezeigt werden sollen (wenn _eine_ Abfrage nicht funktioniert, k√∂nnen die anderen weiterlaufen - oder nicht)
- Es gibt eine fertige, generische Error-Boundary-Komponente: [react-error-boundary](https://www.npmjs.com/package/react-error-boundary)
- Auch TanStack Query hat eine Error-Boundary-Komponente, [QueryErrorResetBoundary](https://tanstack.com/query/latest/docs/framework/react/reference/QueryErrorResetBoundary)
  - Mit dieser gibt es die M√∂glichkeit, einen fehlerhaften Query wiederholen zu lassen (auch durch User-Interaktion, z.B. Button click)

---
### Priorisierung
* Mit Suspense k√∂nnt ihr einzelne Teile der UI priorisieren
* Ihr k√∂nnt z.B. steuern, welche Teile schon dargestellt werden sollen, auch wenn noch andere Daten fehlen
* ...oder das auf _alle_ Daten gewartet werden soll
* Was jeweils "richtig" ist, h√§ngt von den fachlichen Anforderungen ab
---
### Priorisierung
* In der `PostPage` werden Daten aus zwei Requests ben√∂tigt: der Blog-Post und Informationen √ºber dessen Autoren
* Beide Requests k√∂nnen zeitgleich (oder nacheinander) gestartet werden
* Durch das Festlegen der Suspense-Komponente k√∂nnt ihr ausdr√ºcken, welche Teile wichtig sind (sofort rendern, sobald Daten da sind), oder "unwichtig"
* Was passiert hier:
* ```typescript
  function PostPage() {
    const {data: user} = useSuspenseQuery(/* User */);
    const {data: post} = useSuspenseQuery(/* Post */);

    // ...
  }
  ```
* React rendert Komponente bis zum ersten `useSuspenseQuery`
* Wenn die Daten da sind, wird die Komponente nochmal gerendert
* Diesmal bis zum zweiten `useSuspenseQuery`
* Die Daten werden also *nacheinander* nicht *parallel* geladen. üò¢
---
### Priorisierung mit TanStack Query
* Um die Daten parallel zu laden, k√∂nnt ihr TanStack Query anweisen, Daten in den Cache zu laden, *ohne* darauf zu warten
* Dazu verwendet ihr `QueryClient.ensureData`, das die selben Parameter wie `useSuspenseQuery` bzw. `useQuery` entgegennimmt
* TanStack Query startet dann den Request im Hintergrund (und legt die Daten in den Cache, sobald sie vorliegen)
* Um also *nicht* auf die User-Daten zu warten k√∂nnt ihr folgendes tun:
* ```typescript
  function PostPage({postId}) {
    const queryClient = useQueryClient();
    queryClient.ensureData({queryFn: /* ... */, queryKey: ["post", postId, "user"]}); 
    const {data: post} = useSuspenseQuery(/* Post */);

    return ...;
  }
  ```
* Hier werden beide Requests gestartet und React wartet dann auf das Ergebnis des Post-Queries
* In einer weiteren Komponente k√∂nntet ihr dann auf die User-Daten warten, die im besten Fall dann sogar schon im Cache sind:
* ```typescript
  function User({postId}) {
    // Query-Key muss mit dem Query-Key von oben √ºbereinstimmen!
    const data = useSuspenseQuery({queryFn: /* ... */, queryKey: ["post", postId, "user"]}); 

    // User-Daten rendern

    return ...;
  }
  ```
---
## √úbung: Suspense

* Die `PostPage` soll den BlogPost *und* User-Daten anzeigen
* Die Queries f√ºr das Laden der User-Daten sind bereits fertig 
  * kopiere bitte die Dateien `material/use-user-query.ts` und `material/UserDetails.tsx` in dein `src`-Verzeichnis
* Integriere die `UserDetails`-Komponente in die `PostPage`-Komponente  
  * Lege darum herum eine `Suspense`-Komponente. 
* Stelle nun `get-post.ts` auf `useSuspenseQuery` um
* Kannst Du die `PostPage`-Komponente so bauen, dass...
  - ...beide Komponenten (Post und UserDetails) erst gerendert werden, wenn f√ºr *beide* Komponenten die Daten geladen wurden
  - ...die Komponenten jeweils sofort gerendert werden, wenn ihre jeweiligen Daten vorhanden sind
* Hinweise:
  * Du kannst Du Lade-Zeiten mit `?slow=TIMEOUT_IN_MS` in den URLs verz√∂gern
  * Am besten funktioniert Suspense, wenn Du erst die Blogliste aufrufst, und dort dann einen BlogPost anklickst
* L√∂sung: `steps/45_suspense_02`


  </textarea
          >
        </section>

        <!-- ============================================================================= -->
        <section>
          <h2>Geschafft! üòä</h2>
          <h3>Vielen Dank f√ºr Eure Teilnahme!</h3>
          <h3>Viel Spa√ü und Erfolg mit React!</h3>
          <p>Wenn ihr noch Fragen habt, k√∂nnt ihr mich erreichen:</p>
          <p>
            Mail:
            <a href="mailto:nils@nilshartmann.net">nils@nilshartmann.net</a>
          </p>
          <p>
            Web:
            <a href="https://nilshartmann.net" target="_blank"
              >https://nilshartmann.net</a
            >
          </p>
          <p>
            Twitter:
            <a href="https://twitter.com/nilshartmann" target="_blank"
              >@nilshartmann</a
            >
          </p>
        </section>
      </div>
    </div>

    <script src="slides/revealjs/reveal.js/dist/reveal.js"></script>
    <script src="slides/revealjs/reveal.js/plugin/notes/notes.js"></script>
    <script src="slides/revealjs/reveal.js/plugin/markdown/markdown.js"></script>
    <script src="slides/revealjs/reveal.js/plugin/highlight/highlight.js"></script>
    <script src="slides/revealjs/config.js"></script>
  </body>
</html>
