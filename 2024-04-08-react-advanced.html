<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />

    <title>React Vertiefung</title>

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta
      name="apple-mobile-web-app-status-bar-style"
      content="black-translucent"
    />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui"
    />
    <link rel="stylesheet" href="slides/revealjs/reveal.js/dist/reset.css" />
    <link rel="stylesheet" href="slides/revealjs/reveal.js/dist/reveal.css" />
    <link
      rel="stylesheet"
      href="slides/revealjs/reveal.js/dist/theme/solarized.css"
    />

    <!-- Theme used for syntax hislides/ghlighted code -->
    <link
      rel="stylesheet"
      href="slides/revealjs/highlight-js-github-theme.css"
    />
    <link rel="stylesheet" href="slides/revealjs/styles.css" />
  </head>

  <body>
    <div class="reveal">
      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section data-state="title">
          <h2 class="title" style="font-size: 7rem">
            <b>React Vertiefung</b>
          </h2>

          <h4>
            <span class="transparent-bg">
              <a href="https://nilshartmann.net" target="_blank"
                >Nils Hartmann</a
              >
              |
              <a href="https://twitter.com/nilshartmann" target="_blank"
                >@nilshartmann</a
              >
            </span>
          </h4>
          <p style="margin-top: 4rem"></p>
          <div>
            <h3><span class="transparent-bg">Repository</span></h3>
            <p>
              <span class="transparent-bg"
                >Remote:
                <a href="https://github.com/nilshartmann/react18-training"
                  >https://github.com/nilshartmann/react18-training</a
                ></span
              >
            </p>
          </div>
          <p style="margin-top: 4rem"></p>
          <div>
            <h3><span class="transparent-bg">Slides</span></h3>
            <p>
              <span class="transparent-bg"
                >Lokal: 2024-04-08-react-advanced.html</span
              >
            </p>
            <p>
              <span class="transparent-bg"
                >Remote:
                <a
                  href="https://nilshartmann.github.io/react18-training/2024-04-08-react-advanced.html"
                  >https://nilshartmann.github.io/react18-training/2024-04-08-react-advanced.html</a
                ></span
              >
            </p>
          </div>
        </section>
        <section>
          <h2>Nils Hartmann</h2>
          <p>
            <a href="https://nilshartmann.net" target="_blank"
              >https://nilshartmann.net</a
            >
            /
            <a href="https://twitter.com/nilshartmann" target="_blank"
              >@nilshartmann</a
            >
          </p>
          <p>
            <em
              >Freiberuflicher Software-Entwickler, Berater und Trainer aus
              Hamburg</em
            >
          </p>

          <div style="display: flex; justify-content: center">
            <div>
              <p>Java</p>
              <p>JavaScript, TypeScript</p>
              <p>React</p>
              <p>Single-Page-Applications</p>
              <p>GraphQL</p>
              <p style="margin-top: 20px">
                <a href="https://nilshartmann.net/workshops"
                  >Schulungen und Workshops</a
                >
              </p>
            </div>
            <div style="margin-left: 15px">
              <a href="https://reactbuch.de"
                ><img
                  style="max-height: 450px"
                  src="slides/images/react-buch-v2.jpg"
                /><br />https://reactbuch.de</a
              >
              <br />
            </div>
          </div>
        </section>

        <!-- ============================================================================= -->
        <section data-markdown>
          <textarea data-template>
## Agenda
<!-- .slide: class="no-fragment xleft" -->
**_"Modernes Data- und Statemanagement"_**

* **Montag**
  * [Context API](#/t-context)
    * Neuerungen in [React 19](#/t-react19) 
    * Renderzyklen optimieren mit [useCallback, useMemo](#/t-context-render)
  * [TanStack Query](#/t-tanstack-query)
    * "Modernes" React: Data Fetching mit Suspense

* **Dienstag**
  * Code Review, m√∂gliche Refaktorings, ...

          </textarea>
        </section>

        <!-- ============================================================================== -->
        <!-- ====                                                                      ==== -->
        <!-- ====            C O N T E X T                                             ==== -->
        <!-- ====                                                                      ==== -->
        <!-- ============================================================================== -->
        <section id="t-context">
          <h3>Hintergrund: Daten und State</h3>
          <ul>
            <li>Serverseitige <b>Daten</b> und clientseitiger <b>State</b></li>
            <li>Arten von State: <b>lokal</b> und <b>global</b></li>
            <li>√úberblick: üëâ Daten und State</li>
          </ul>
        </section>
        <section>
          <h3>Hintergrund: Globaler Zustand</h3>
          <ul>
            <li>
              Man kann Zustand in <b>lokalen Zustand</b> und
              <b>globalen Zustand</b> einteilen
            </li>
            <li>
              <b>Lokaler Zustand</b> ist Zustand, der "mehr oder weniger" einer
              Komponente zur Verf√ºgung steht
            </li>
            <li>
              <b>Globaler Zustand</b> hingegen ist f√ºr die ganze Anwendung oder
              gro√üe Teile davon zust√§ndig
            </li>
            <li>Die √úbgerg√§nge sind flie√üend, es gibt keine fixe Definition</li>
            <li>
              Beispiele f√ºr globalen Zustand: angemeldeter Benutzer, Theme
            </li>
          </ul>
        </section>
        <section>
          <h2>React Context API</h2>
          <p>Kein Statemanagement, aber h√§ufig zusammen erw√§hnt</p>
          <p>"Dependency Injection"</p>
          <p>√úberblick: üëâ Anwendungshierachie mit State und Props (Miro)</p>
        </section>

        <!-- ============================================================================= -->

        <section>
          <h2>Im Detail: Context API</h2>
          <p>Beispiel: <code>20_context/workspace</code></p>
          <p>
            In <code>Container.tsx</code> Anzeige der Border einschalten (<code
              >hideBorder = false</code
            >)
          </p>
          <p><code>CounterApp</code> rendern!</p>
          <p>
            In <code>Container.tsx</code> Anzeige der Renderings einschalten
            (<code>showRenderings = true</code>)
          </p>
          <p>
            (Material in
            <code>context-example/material/CounterContext.txt</code>)
          </p>
        </section>

        <section>
          <h2>Context...</h2>
          <p>
            <em
              >erlaubt das Durchreichen von Informationen ohne explizites
              angeben als Properties</em
            >
          </p>

          <ul>
            <li>funktioniert nur innerhalb einer Hierarchie-Ebene</li>
            <li>
              es k√∂nnen beliebg viele (fachliche) Context definiert werden
            </li>
            <li>besteht aus <code>Provider</code> und <code>Consumer</code></li>
            <li>
              <a href="https://reactjs.org/docs/context.html" target="_blank"
                >Doku</a
              >
            </li>
          </ul>
        </section>

        <section>
          <h2>Context Factory</h2>
          <ul>
            <li>
              <em>erzeugt ein Objekt, mit <b>zwei Komponenten</b></em>
            </li>
            <li>
              <code>Provider</code>, stellt Objekt mit Key-Value-Paaren zur
              Verf√ºgung (der Context-"Value")
            </li>
            <li>
              <code>Consumer</code> wird in eigener Komponente verwendet, um auf
              einen Context zuzugreifen ("versteckt" durch useContext Hook)
            </li>
            <li>
              <pre><code class="line-numbers" data-leftpad>
import react from "React";

const AuthContext = React.createContext();

// erzeugt:
// AuthContext.Provider 
// AuthContext.Consumer (mit Hooks API √ºberfl√ºssig)

export AuthContext;
                      </code></pre>
            </li>
          </ul>
        </section>

        <section data-markdown>
          <textarea data-template>
## Context Factory mit TypeScript

* Der `createContext` kann ein Typ-Parameter √ºbergeben werden, der den Context-Wert beschreibt
* `createContext` ben√∂tigt dann einen Default-Wert, der diesem Typen entspricht
  * Der Default-Wert wird in der Anwendung in der Regel nicht verwendet
  * Wird nur verwendet, wenn (f√§lschlich) auf den Kontext zugegriffen wird, ohne dass es einen Provider
    gibt
* ```typescript
  type IAuthContext = { 
    username: string | null;
    onLogin(newUser: string): void;
    onLogout(): void;
  }

  const AuthContext = React.createContext<IAuthContext>({
    // Dummy-Implementierung vom Default Context
    username: null,
    onLogin() {},
    onLogout() {}
  });

  export AuthContext;
  ```

          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
## Context Provider

* _Eine React-Komponente, die einen Context zur Verf√ºgung stellt_
  * wird innerhalb einer eigenen Komponente eingebunden und zur√ºckgeliefert
  * Nimmt ein Objekt ("Context") mit beliebigen Werten entgegen (`value`-Property)
  * Woher die Werte kommen (State, Props, anderer Kontext, ...) spielt keine Rolle!
  * Alle Eintr√§ge des Objektes sind f√ºr die Konsumenten verf√ºgbar
* ```typescript
  const AuthContext = React.createContext&lt;IAuthContext>(/*...*/); // wie gesehen

  type AuthProviderProps = {
    children: React.ReactElement
  }

  export function AuthProvider(props: AuthProviderProps) {
      const [ currentUser, setCurrentUser ] = React.useState(null);

      const contextValue: IAuthContext = {
        // the current user
        currentUser,

        // function to set new user
        function onLogin(name) { setCurrentUser(name) },
        function onLogout() { setCurrentUser(null) }
      };

      return &lt;AuthContext.Provider value={contextValue}>
        {props.children}
      &lt;/AuthContext.Provider>;
  }             
  ```
  </textarea
          >
        </section>

        <section>
          <h2>useContext-Hook</h2>
          <p><em>Zugriff auf die Werte aus dem Context</em></p>
          <p>
            In allen Komponenten unterhalb der Provider Komponente, kann mit
            <code>useContext</code> auf den Kontext zugegriffen werden
          </p>

          <pre><code class="javascript">
import { AuthContext } from "auth-context";

function UserBadge() {
  const { currentUser } = React.useContext(AuthContext);

  return currentUser  ? &lt;h1>Welcome, {currentUser}&lt;h1> : null;
}            
          </code></pre>

          <p>Aufrufen einer Funktion aus dem Context</p>
          <p>√Ñndert im Context den Zustand der Provider-Komponente</p>
          <p>
            Alle Konsumer werden neu gerendert und k√∂nnen den neuen Wert
            verwenden
          </p>
          <pre><code class="javascript">
function UserBadge() {
  const { currentUser, logout } = React.useContext(AuthContext);

  return currentUser  ? 
    &lt;>&lt;h1>Welcome, {currentUser}&lt;h1>&lt;button onClick={logut}>Logout&lt;/button>&lt;/> 
    : null;
}                
          </code></pre>
        </section>

        <section data-markdown>
          <textarea data-template>
## Zugriff mit Custom Hook

* √úbliches Pattern: f√ºr den Zugriff auf den Context wird ein eigener Hook zur Verf√ºgung gestellt
* ```typescript
  export function useAuthContext(): IAuthContext {
    const authContext = useContext(AuthContext);

    return authContext;
  }            
  ```
* ```typescript
  import { useAuthContext } from "auth-context";
  
  export default function UserBadge() {
    const authContext = useAuthContext();
  }
  ```  

  * "Versteckt" den Context (Implementierungsdetail!) vor der Anwendung
  * Sieht aus wie fachliche API
  * Kann (vergleichsweise einfach) gemockt werden
---
###  Zugriff mit Custom Hook in TypeScript
* Beim Erzeugen des Context muss man (in TypeScript) einen Default Context angeben:
* ```typescript
  const defaultContext: IAuthContext = {
      // Dummy-Implementierung vom Default Context
      username: null, onLogin() {}
  }
  const AuthContext = React.createContext<IAuthContext>(defaultContext);
  ```
* Das ist nicht immer (sinnvoll) m√∂glich, so dass man auch `ContextType | null` verwenden k√∂nnte:
* ```typescript
  const AuthContext = React.createContext<IAuthContext | null>(null);
  ```
* Nun liefert `useContext` aber immer auch `null` zur√ºck, so dass die Verwendung jedes Mal √ºberpr√ºft werden muss:
* ```typescript
  function UserBadge() {
    const { username } = useContext(AuthContext); // ERR: Property 'username' does not exist on type 'IAuthContext | null'
  }
  ```
 
* Mit dem Custom Hook kann eine Plausibilit√§tspr√ºfung durchgef√ºhrt werden und ggf. ein sprechender Fehler erzeugt werden:
* ```typescript
  
  export function useAuthContext(): IAuthContext {
    const authContext = useContext(AuthContext);

    if (authContext === null) {
      throw new Error("AuthContext not correctly initialized. Please wrap your application in a AuthContextProvider component");
    }

    return authContext;
  }            
  ```  

---
### Ein "halbglobaler" Context
<!-- .slide: class="left" -->
* Ein Formular hat eine beliebige Menge von Feldern und Button
* Kann man da mit Context was machen? ü§î

* ```typescript
  
    type FormState = Record<string, string>;

    function PersonForm() {
      const [formState, setFormState] = React.useState<FormState>({});

      function onClearForm() {
        setFormState({});
      }

      function onFieldChange(fieldname: string, value: string) {
        setFormState({
          ...formState,
          [fieldname]: value
        });
      }

      return (
        <Container title="PersonForm">
          <FieldSet>
            <Input name="firstname" formState={formState} onFieldChange={onFieldChange} />
            <Input name="lastname" formState={formState} onFieldChange={onFieldChange} />
          </FieldSet>
          <ClearButton onClearForm={onClearForm} />
        </Container>
      );
    }

  ```

---
## √úbung: Ein Notification Context

* *Baue einen Kontext, der eine globale Notification anzeigt*
* <!-- .element: class="demo" -->Ergebnis zeigen
* Schritte:
  * In `20_context/workspace` bitte Abh√§ngigkeiten installieren und npm starten:
  * ```bash
    cd 20_context/workspace

    npm install
    npm start 
    ```
* In `NotificationContext.tsx` soll ein Context implementiert werden, der Informationen
            √ºber die anzuzeigene Notification enth√§lt
* In `NotificationApp.tsx` sind React-Komponenten implementiert. Diese sollen den Context dann nutzen
* N√§here Informationen findest Du direkt in beiden Dateien
* Du solltest mit der Implementierung des `NotificationContext` anfangen
* M√∂gliche L√∂sung findest Du in `material/02_solution`
* Wenn Du fertig bist, bitte "Hand heben" in Zoom üôãÔ∏è

---
### Renderverhalten von Context

* Lasst uns mal √ºberlegen, ob es sinnvoll ist, f√ºr die Verwendung unseres `NotificationContext` mehrere Hooks zu bauen:
  * zum Beispiel zum Setzen des Context
  * zum Beispiel zum Zugriff nur auf die √ºbersetzte Message
  * ...oder auch nur auf die Information, ob √ºberhaupt etwas gesetzt ist
* hilft uns das beim Optimieren des Renderings? ü§î
* was f√ºr einen Vor- oder Nachteil h√§tte dieser Ansatz dar√ºberhinaus? ü§î
---
### Renderverhalten von Context

* Bei jeglicher √Ñnderung des Contexts werden immer alle Konsumenten neu gerendert
  * unabh√§ngig davon, ob diese sich f√ºr den Teil interessieren, der sich ge√§ndert hat
  * das k√∂nnen wir nicht vermeiden (evtl. in einer kommenden React Version)
* Aus diesem Grund sollte man den Context nicht unbedingt verwenden, wenn
  * darin Daten enthalten sind die sich h√§ufig bzw. schnell √§ndern (Inhalt eines Eingabefeldes z.B.)
  * und von diesen √Ñnderungen sehr viele Komponenten betroffen sind (direkt oder indirekt)


---
### Neuerungen in React 19
<!-- .slide: id="t-react19" --> 

* [React 19](https://react.dev/blog/2024/02/15/react-labs-what-we-have-been-working-on-february-2024) wird im Laufe des Jahres erscheinen
* Darin wird sich auch die Context API ver√§ndern:
  * Es wird eine `Context`-Komponente geben (ersetzt `Context.Provider`)
  * `useContext` wird durch den `use`-Hook ersetzt
  * Der `use`-Hook ist flexibler als die bisherigen Hooks
  * Kann √ºberall verwendet werden (z.B. in `if`)
  * Das ganze ist (weitgehend) abw√§rtskompatibel! 
* Die APIs `useCallback`, `useMemo` und `memo` werden durch den **React Compiler** (ehem. Codename: "Forget") ersetzt
  * Unklar, ob der Compiler Teil von React 19 wird, da es ein eigenes Projekt ist



          </textarea>
        </section>
        <section data-transition="slide none">
          <h2>Was testen wir?</h2>
          <ul>
            <li>
              <b>UI-unabh√§ngige Logik</b> (zum Beispiel Backend Calls,
              Berechnungen etc.)
            </li>
            <li>
              <b>Rendering</b> (Ist die Liste der Blog Posts korrekt? Sieht das
              Markup aus, wie wir uns das vorstellen?) und
              <b>Interaktionen</b> (funktionieren die Event Handler, die
              Callback-Funktionen, der Programmflu√ü etc.?)
            </li>
            <li>
              <b>Verhalten im Browser</b> (z.B. korrekte, pixelgenaue
              Darstellung, Browser-spezifisches JavaScript, Arbeiten mit
              Browser-Technologie wie Titelzeile, Session Storage, Scrollbars
              etc)
            </li>
          </ul>
        </section>

        <section>
          <h1>Jest</h1>
          <p>
            <em
              >"Delightful JavaScript Testing" (
              <a href="https://jestjs.io/" target="_blank">https://jestjs.io/</a
              >)</em
            >
          </p>
          <p>Vollst√§ndige Testl√∂sung f√ºr React (und andere):</p>
          <ul>
            <li>Test Runner</li>
            <li>Specs/Assertions, Mocks</li>
            <li>Code Coverage</li>
          </ul>
        </section>
        <section>
          <h1>Vitest</h1>
          <p class="fragment">
            Falls ihr mit Vite arbeitet, bietet sich
            <a href="https://vitest.dev/"> Vitest </a> an.
          </p>
          <ul>
            <li>
              Das ist deutlich moderner als Jest und arbeitet auch besser mit
              dem ECMAScript Modulsystem (ESM) und TypeScript zusammen
            </li>
            <li>
              Vitest hat eine sehr √§hnliche API wie Jest und ein vergleichbares
              Feature-Set
            </li>
            <li>
              Es gibt auch einen<a
                href="https://vitest.dev/guide/migration.html#migrating-from-jest"
                >Migrationspfad von Jest</a
              >
            </li>
          </ul>
        </section>
        <section>
          <h4>Jest</h4>
          <h3>Beispiel: Ein einfacher Testfall</h3>
          <pre><code class="javascript">// sum.js (or sum.ts)
export const sum = (a,b) => a+b;
        </code></pre>
          <pre><code class="javascript">// sum.test.js
import {sum} from '../sum.js';

test('sum of 2 and 2 is 4', () => {
  expect(sum(2, 2)).toBe(4);
});

test('sum of 2 and 2 is not 3', () => {
  expect(sum(2, 2)).not.toBe(3);
});
            </code></pre>
        </section>
        <section>
          <h4>Jest</h4>
          <h2>Testcases</h2>
          <p>
            <code>test</code> oder
            <code>it</code>
          </p>
          <pre><code>test('it should work', () => {
  expect(...).toBe(...);
});</code></pre>
          <pre><code>it('it should also work', () => {
  expect(...).toBe(...);
});</code></pre>
        </section>

        <section>
          <h4>Jest</h4>
          <h2>"Expectations" und "Matchers"</h2>
          <div>
            <p>
              <code>expect()</code> liefert ein <em>Expectation</em> Objekt
              zur√ºck, das verschiede <em>Matcher</em> Funktionen bereitstellt:
            </p>
            <pre><code>expect(actual).toXyz(expected);
// for example:
expect("Hello Jest").toBe("Hello Jest"); // => ok
        </code></pre>
          </div>
          <div>
            <p>Beispiele f√ºr Matchers</p>

            <pre><code>// Compare identity
expect(actual).toBe(expected);
// Compare value:
expect(actual).toEqual(expected);
// true / false / null:
expect(actual).toBeTruthy();
expect(actual).toBeFalsy();
expect(actual).toBeNull();
// Length (Array oder String)
expect(actual).toHaveLength(123);
        </code></pre>
          </div>
          <p>
            <a href="https://jestjs.io/docs/en/expect"
              >https://jestjs.io/docs/en/expect</a
            >
          </p>
        </section>

        <section>
          <h4>Jest</h4>
          <h2>Mock Funktionen</h2>
          <ul>
            <li>
              <code>jest.fn()</code> erzeugt eine Mock-Funktion
              <pre><code>// Gibt undefined zur√ºck, wenn die Mock-Funktion ausgef√ºhrt wird
const aMockFn = jest.fn();

const x = aMockFn("hello", "world"); // => undefined
expect(x).toBeUndefined();
              </code></pre>
            </li>
            <li>
              Mit <code>toHaveBeenCalled</code>-Matcher-Funktionen kann gepr√ºft
              werden, ob der Mock aufgerufen wurde, wie h√§ufig und mit welchen
              Parametern:
              <pre><code>
expect(aMockFn).toHaveBeenCalled());  // Mock wurde aufgerufen (Parameter werden ignoriert)
expect(aMockFn).toHaveBeenCalledWith("hello", "world")); // Mock wurde mit 'huhu' aufgerufen
expect(aMockFn).toHaveBeenCalledTimes(1)); // Mock wurde genau einmal aufgerufen

// √úbergebene Paramter stehen √ºber .mock.calls:
expect(aMockFn.mock.calls[0][0]).toBe("hello");
expect(aMockFn.mock.calls[0][1]).toBe("world");
                      </code></pre>
            </li>
            <li>
              Implementierung der Mock-Funktion kann als Parameter √ºbergeben:
              <pre><code>
        const aMockFn = jest.fn( param => `Hello, ${param}` );

        console.log(aMockFn('World'));
        // => Hello, World
                  </code></pre>
            </li>
          </ul>
        </section>
        <section>
          <h4>Jest</h4>
          <p><b>Achtung:</b></p>
          <p>
            Je nach Jest-Version und Setup m√ºsst ihr das
            <code>jest</code>-Objekt importieren
          </p>
          <p><code>import { jest } from "@jest/globals";</code></p>
          <p>
            (Die <code>test</code>-Funktion funktioniert in der Regel ohne
            import...)
          </p>
        </section>

        <section>
          <h3>Testen von React Komponenten</h3>
        </section>

        <section>
          <h3>react-testing-library</h3>
          <p>
            <em
              >"Simple and complete React DOM testing utilities that encourage
              good testing practices."
            </em>
          </p>

          <p>
            <a
              href="https://github.com/testing-library/react-testing-library"
              target="_blank"
              >https://github.com/testing-library/react-testing-library</a
            >)
          </p>
          <p>
            Philosophie: Tests werden aus User-Perspektive geschrieben. Das
            bedeutet, um die zu testenden Elemente zu finden, suchst Du nach
            Eigenschaften, nach denen auch ein User suchen w√ºrde (z.B. Labels,
            Placeholder etc.)
          </p>
        </section>
        <section>
          <h3>react-testing-library</h3>
          <p>Example</p>
          <p>Demo: 20_context/workspace/src/__tests__/PostEditor.test.tsx</p>
          <pre><code class="javascript">
            import { render, screen } from "@testing-library/react";
            import _userEvent from "@testing-library/user-event";
            import { jest } from "@jest/globals";


            it("invokes callback on button click", () => {
              const user = _userEvent.setup();

              const onAddPostFn = jest.fn();

              // Render
              render(&lt;PostList onAddPost={onAddPostFn} posts={mockPosts} />);

              // search the button
              const buttonElement = screen.getByRole("button", { name: "Add Post" });

              // "click" the button
              await user.click(buttonElement);

              // make sure it has been invoked
              expect(onAddPostFn).toHaveBeenCalled();
            });

            </code></pre>
        </section>

        <section>
          <h3>React Testing Library im Detail</h3>
        </section>

        <section>
          <h3>Die render-Funktion</h3>
          <ul>
            <li>
              Die render-Function aus der react-testing-library wird im Test
              verwendet, um eine React Komponente (ohne Browser) zu rendern
            </li>
            <li>
              Genauso wie in der Anwendungen k√∂nnen Properties angegeben werden
            </li>
            <li>
              <pre><code class="javascript">
import { render } from "@testing-library/react";

// Render a single component
render(&lt;PostList onAddPost={onAddPostFn} posts={mockPosts} />);
            </code></pre>
            </li>
            <li>
              Dran denken, ggf. Contexte ebenfalls zu erzeugen, falls diese
              ben√∂tigt werden (eigener Context, Router, MaterialUI, etc)!
            </li>
            <li>
              <pre><code class="javascript">

// Render with surrounding Redux Provider (or Router, your own Context etc.)
render(
  &lt;NotificationContextProvider>
    &lt;PostEditor onSavePost={onSavePostFn}  />
  &lt;/NotificationContextProvider>
);
            </code></pre>
            </li>
          </ul>
        </section>

        <!-- ######################################################################################### ########################## -->

        <section>
          <h3>query Funktionen</h3>
          <p>
            Um die gerenderten HTML-Elemente aus deiner Komponente zu √ºberpr√ºfen
            und mit ihnen zu interagieren, musst Du sie ersteinmal finden ü§ì
          </p>
          <p>
            Auf dem globalen <b>screen</b> Objekt der Testing-Lib sind
            verschiedene Funktionen definiert, mit denen Du nach Elementen
            suchen kannst
          </p>
          <p>
            Die query-Funktionen haben unterschiedliche <b>Suffixe</b>, die
            beschreiben, <b>nach welchem Kriterium</b> Du suchst (nach Label,
            nach aria-role, ...)
          </p>
          <p>
            Die Funktionen haben au√üerdem jeweils einen <b>Pr√§fix</b> (getBy,
            queryBy etc) der beschreibt, die Art des R√ºckgabewerts der jeweilgen
            Funktion (z.B. ob sie einen Error wirft oder null zur√ºckgibt, wenn
            das angefragte Element nicht gefunden wurde)
          </p>
          <p>
            Mehr zu den query-Funktionen:
            <a
              target="_blank"
              href="https://testing-library.com/docs/react-testing-library/cheatsheet#queries"
              >React Testing Library Cheatsheet</a
            >
          </p>

          <pre><code class="javascript">
  // BEISPIELE:
  import { screen } from "@testing-library/react";

  // suche nach einem Button (Annahme: es gibt GENAU EINEN, ansonsten schl√§gt der Test fehl)
  const buttonElement = screen.getByRole("button", { name: "Add Post" });

  // suche nach einem Button (gibt null oder EINEN Button, wirft ansonst einen Fehler)
  const buttonElement = screen.queryByRole("button", { name: "Add Post" });
  // das verwendet man eigentlich nur, um zu testen, dass ein Element NICHT vorhanden ist:
  expect(screen.queryByRole("button", { name: "Create Post" })).not.toBeInTheDocument();

  // suche nach einem Button (gibt alle gefunden zur√ºck oder ein leeres Array)
  const buttonElement = screen.queryAllByRole("button", { name: "Add Post" });
</code></pre>
        </section>

        <section>
          <h3>√úberpr√ºfen von Elementen</h3>
          <p>
            Wenn Du dein gesuchtes Elemente gefunden hast, kannst Du es
            √ºberpr√ºfen, ob es deinen Erwartungen entspricht (korrekte Attribute
            gesetzt etc.)
          </p>
          <p>
            Die Bibliothek
            <a
              href="https://github.com/testing-library/jest-dom"
              target="_blank"
              >jest-dom</a
            >
            f√ºgt dazu DOM-spezifiche Matcher f√ºr Jest hinzu.
          </p>

          <pre><code class="javascript">
  import { screen } from "@testing-library/react";

  expect(screen.getByRole("button", { name: "Add Post" })).toBeInTheDocument();

  // stellt sicher, dass das Element im DOM vorhanden ist (getBy-Query w√ºrde hier vielleicht mehr Sinn machen)
  expect(buttonElement).toBeInTheDocument();

  // sicherstellen, dass ein Eingabefeld einen erwarteten Wert hat
  expect(titleInput).toHaveValue("Moin moin");

  // sicherstellen, dass ein Button disabled ist
  expect(okButton).toBeDisabled();
</code></pre>
          <p>
            Alle Matcher sind auf der oben verlinkten GitHub Seite dokumentiert
          </p>
        </section>
        <section>
          <h3>Interaktionen</h3>
          <p>
            Du kannst mit den Elementen interagieren, in dem Du ihnen Events
            sendest, genau wie es ein Browser tun w√ºrde
          </p>
          <p>
            Es gibt eine weitere Bibliothek,
            <a
              href="https://github.com/testing-library/user-event"
              target="_blank"
            >
              user-event</a
            >, die dir dabei hilft, die Events zu erzeugen.
          </p>

          <pre><code class="javascript">
            import userEvent from "@testing-library/user-event";
            // Simuliert die Eingabe in ein Textfeld
            userEvent.type(titleInput, "New Title");

            // Simuliert den Klick auf einen Button
            userEvent.click(clearButton);
          </code></pre>
          <p>
            Achtung! In neueren Versionen (ab v14) der Bibliothek muss man erst
            setup-Aufrufen.
          </p>
          <p>
            Au√üerdem sind die Funktionen nun asynchron, so dass Du mit
            <code>await</code> auf deren Beendigung warten musst!
            <b>Das ist ganz wichtig!</b>
          </p>
          <pre><code class="javascript">
            import _userEvent from "@testing-library/user-event";

            test("...", async () => {
              const userEvent = _userEvent.setup();
              // Simuliert die Eingabe in ein Textfeld
              await userEvent.type(titleInput, "New Title");

              // Simuliert den Klick auf einen Button
              await userEvent.click(clearButton);
            })
          </code></pre>
          <p>Alle Events sind auf der GitHub Seite beschrieben (Link oben)</p>
        </section>

        <section data-markdown>
          <textarea data-template>
## Der Testing Playground

* https://testing-playground.com/
* Hier kann man HTML-Code reinkopieren, mit dem man dann Query-Funktionen ausprobieren kann
* Dazu gibt es auch eine Browser-Erweiterung f√ºr [Chrome](https://chrome.google.com/webstore/detail/testing-playground/hejbmebodbijjdhflfknehhcgaklhano)
* Mit `screen.logTestingPlaygroundURL()` kann man eine URL ausgeben lassen, die den im Test gerenderten HTML-Code direkt im Playground √∂ffnet
          </textarea>
        </section>
        <section data-markdown>
          <textarea data-template>
## √úbung: Tests f√ºr den PostEditor

* Im Workspace-Verzeichnis (`20_context/workspace`) gibt es einen PostEditor
* Um den auszuprobieren kannst Du den in `main.tsx` rendern lassen (statt `NotificationApp`)
* F√ºr diesen PostEditor solltest Du einige Tests schreiben
* Ein "Template" daf√ºr ist bereits im `__tests__`-Ordner vorhanden
* Ausf√ºhren kannst Du die Tests mit `npm test`
  * Dieser Prozess l√§uft "ewig" und f√ºhrt die Tests automatisch beim Speichern aus
* Alternativ kannst Du die Tests auch in IDEA ausf√ºhren
* L√∂sung: `material
* Wenn Du fertig bist, bitte "Hand heben" üôã‚Äç
          </textarea>
        </section>
        <section data-markdown>
          <textarea data-template>
### Testen von (Custom) Hooks

* Hooks k√∂nnt ihr nicht "einfach so" aufrufen und Testen, denn die setzen zur Laufzeit ja die React Infrastruktur voraus
* Es gibt zwei M√∂glichkeiten:
  1. Ihr schreibt euch im Test eine Wrapper-Komponente, die den Hook verwenden und testet die dann "wie gewohnt"
  2. Ihr verwendet `renderHook`
* <!-- .element: class="demo" --> `useCounter.test.tsx`
---
### renderHook
* `renderHook` erwartet eine Callback-Funktion. In dieser Callback-Funktion k√∂nnt ihr euren Hook dann aufrufen.
* Als Beispiel soll folgender Custom Hook dienen, der ein Objekt mit einem  Z√§hler und eine Funktion zum Hochsetzen des Z√§hlers zur√ºckliefert:
* ```typescript
  // Diesen Hook wollen wir testen:
  function useDemoCounter() {
    const [count, setCount] = useState(100);

    function increaseCount() { setCount(count + 1); }

    return { count, increaseCount };
  }
  ```
* Zum "rendern" dieses Hooks verwendet ihr `renderHook` aus der testing-library:
* ```typescript

  import { renderHook } from "@testing-library/react";

  test("useDemoCounter Works", () => {
    const { result } = renderHook(() => useDemoCounter());

    // ....
  });
  ```
---
### renderHook
* `renderHook` liefert ein Objekt zur√ºck, das unter anderem ein `result` Property kennt
* Darauf wiederrum ist das `current`-Property definiert, das den R√ºckgabewert eures Hooks enth√§lt
* Dieses k√∂nnt ihr zum √úberpr√ºfen der Daten verwenden:
* ```typescript
  test("useDemoCounter Works", () => {
    const { result } = renderHook(() => useDemoCounter());

    expect(result.current.counter).toBe(100);
  });

  ```
---
### Neurendern des Hooks
* Im Test k√∂nnt ihr nicht einfach Funktionen aufrufen, die Euer Hook bereitstellt, die dann die React API verwenden
  * In unserem Fall z.B. geht `result.current.increaseCounter()` nicht, weil darin der State ver√§ndert wird
* In solchen F√§llen m√ºsst ihr den Aufruf mit der `act`-Funktion aus der testing-library wrappen.
* Nach dem Aufruf ist das `result.current` Objekt dann automatisch das aktualisierte R√ºckgabe-Objekt eures Hooks
* ```typescript
  import { act, renderHook } from "@testing-library/react";

  test("useDemoCounter Works", () => {
    const { result } = renderHook(() => useDemoCounter());

    act( () => result.current.increaseCounter() );

    // 'result.current' ist hier automatisch das aktualisierte R√ºckgabe-Ergebnis,
    // das euer Hook in React nach dem neu-rendern zur√ºckliefern w√ºrde
    expect(result.current.counter).toBe(100);
  })
  ```
---
### Testen eines Contexts
* K√∂nnen wir mit den gezeigten Mitteln unseren `useNotification`-Hook testen? ü§î
* Ja, aber...
* Der Hook setzt ja voraus, dass die Provider-Komponente auch gerendert ist!
* Die `renderHook`-Funktion ist darauf vorbereitet. Denn intern generiert sie bereits eine Komponente, die sie im Test um euren Hook herumlegt
* Und diese interne Komponente k√∂nnen wir auch explizit setzen!
* Dazu gibst Du eine `wrapper`-Funktion als zweiten Parameter beim Aufruf von `renderHook` an
* Diese `wrapper`-Funktion muss eine Komponente zur√ºckliefern, die alle erforderlichen Kontexte etc. enth√§lt
* Als Parameter erh√§lt die `wrapper`-Funktion das `children`-Property, dass Du in deiner "Dummy-Komponente" verwenden musst:
* ```typescript
  test("context works", () => {
    const {result} = renderHook(

      // erster Parameter: wie eben schon im useCounter-Beispiel
      () => useNotificationContext(),

      // zweiter Parameter: die wrapper-Komponente
      { wrapper: ({ children }) => (
        <NotificationContextProvider>{children}</NotificationContextProvider>
      )},
    });

    expect(result.current.messageId).toBe(null);
    // ...
  })

  ```
---
## √úbung: Test f√ºr den Notification Context
* Schreibe einen Test f√ºr den NotificationContext
* Du kannst selbst entscheiden, was der beste Weg f√ºr dich ist bzw. welche(n) Du ausprobieren m√∂chtest.
  1. Test-Komponente schreiben, die den Context verwendet und dann die Ausgaben der Test-Komponente √ºberpr√ºfen
  2. `renderHook`-Verwenden
* Eine Vorlage findest Du in `20_context/workspace/__tests__/NotificationContext.test.tsx`
* Eine m√∂gliche L√∂sung findest Du in `20_context/material/04_test_context`
* Bei Fragen oder Problemen kannst Du dich jederzeit melden
* Wenn Du fertig bist, bitte die Hand heben ‚úã
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
## Error Boundaries
* ü§îWas passiert, wenn wir in unserer App vergessen, den `NotificationContextProvider` einzubinden? ü§î
* <!-- .element: class="demo" -->Ausprobieren (NotificationApp.tsx)
---
## Error Boundaries

* Wenn beim **Rendern** etwas schiefgeht, verwirft React "zur Sicherheit" den ganzen Komponenten-Tree
  * (damit nicht z.B. inkonsistente oder fehlerhafte Daten angezeigt werden)
* Das ist nicht besonders benutzerfreundlich
* In einem Event-Handler haben wir dieses Problem nicht: dort k√∂nnen wir z.B. mit try/catch arbeiten
  * oder der Event-Handler wird einfach abgebrochen und die "alte" UI bleibt weiterhin sichtbar
* Beim Rendern k√∂nnen wir aber kein try/catch drumherum legen
* Deswegen gibt es "spezielle" Komponenten: **Error Boundaries**
---
### Error Boundaries
* Error Boundary-Komponenten kann man √ºberall in seiner Komponenten-Hierarchie einziehen
* Render-Fehler, die unterhalb auftreten, werden dann der Error Boundary-Komponente √ºbergeben
  * Diese kann dann z.B. eine Fehler-Komponente darstellen
  * Dieses Verhalten √§hnelt try-catch.
  * Auch try-catch-Bl√∂cke in "normalem" Code k√∂nnt ihr ja auf jeder Ebene des Call-Stacks einziehen
* Ein Beispiel:
* ```typescript
  function MyApp() {
    return (
      <Layout>
        <Header />
        <MyErrorBoundary>
            <Main>
              <BlogPost />
            </Main>
            <NewsletterForm />
        </MyErrorBoundary>
      </Layout>
    )
  }
  ```
* Wenn es hier zum Fehler **w√§hrend des Renderns** kommt:
  * innerhalb von `Layout` oder `Header`: wei√üe Seite, Fehlermeldung auf der Console
  * innerhalb von `Main`, `BlogPost` oder `NewsletterForm`: Error Boundary wird angezeigt, `Layout` und `Header`-Komponente bleiben unver√§ndert (gerendert)
---
### Error Boundaries
* Eine Error Boundary-Komponente ist eine Art `catch`-Block f√ºr die Renderphase von Komponente
* Technisch handelt es sich dabei um eine fast "normale" React-Komponente
* Diese muss allerdings noch mit der (alten) React JavaScript Klassen API gebaut werden
* Diese Klasse muss dann die [getDerivedStateFromError](https://react.dev/reference/react/Component#static-getderivedstatefromerror) Callback-Funktion implementieren
* Einfacher ist es, eine fertige Error Boundary-Komponente zu verwenden: [react-error-boundary](https://github.com/bvaughn/react-error-boundary)
---
### Error Boundary mit `react-error-boundary`
* Die Error Boundary-Komponente aus der Bibliothek hei√üt - √úberraschung! - `ErrorBoundary`
* Die ist sehr flexibel zu konfigurieren
* Man muss ihr eine Komponente √ºbergeben die im Falle eines Fehlers gerendert werden soll
  * (das ist euer "try-Block")
* Diese Komponente bekommt dann als Property u.a. den Fehler √ºbergeben:
* ```typescript
  import { FallbackProps } from "react-error-boundary";

  function AppErrorMessage( { error }: FallbackProps) {

    console.error("Something bad happend:", error);
    return <h1>Something bad happend !</h1>;
  }
  ```
* ```typescript
  import { ErrorBoundary } from "react-error-boundary";
  function MyApp() {
    return (
      <Layout>
        <Header />
        <ErrorBoundary fallback={AppErrorMessage}>
            <Main>
              <BlogPost />
            </Main>
            <NewsletterForm />
        </ErrorBoundary>
      </Layout>
    )
  }

  ```
---
### react-error-boundary
* Der `fallback`-Komponente wird √ºberdies eine Funktion `resetErrorBoundary` √ºbergeben
* Die k√∂nnt ihr aufrufen, dann wird erneut versucht, den Komponenten-Tree unterhalb der `ErrorBoundary`-Komponente zu rendern
* Das macht Sinn wenn es Grund zur Annahme gibt, der Fehler verschwinde sp√§ter (z.B. Netzwerkverbindung ist wieder in Ordnung)
* ```typescript
  import { FallbackProps } from "react-error-boundary";

  function AppErrorMessage( { error, resetErrorBoundary }: FallbackProps) {

    console.error("Something bad happend:", error);
    return (
      <div>
        <h1>Something bad happend !</h1>
        <button onClick={ () => resetErrorBoundary() }>Try again!</button>
      </div>
    );
  }
  ```
* Wenn ihr eine M√∂glichkeit habt, einen fehlerhaften Zustand zu reparieren, k√∂nnt ihr an der `ErrorBoundary`-Komponente eine `onReset`-Funktion angeben
* Diese wird dann aufgerufen, wenn ihr `resetErrorBoundary` in der Fallback-Komponente aufruft
---
### react-error-boundary

* Normalerweise werden Error Boundary-Komponenten von React nur dargestellt, wenn ein Fehler **beim Rendern** auftritt
* Die `ErrorBoundary`-Komponente von `react-error-boundary` k√∂nnt ihr aber auch manuell rendern lassen, wenn z.B. in einem Event ein Fehler auftritt.
  * So k√∂nnt ihr eure Fehlerbehandlung dann auf alle Arten von Fehlern in eurer Anwendung anwenden
* Um die `ErrorBoundary`-Komponente anzuzeigen, verwendet ihr den `useErrorBoundary`-Hook:
* ```typescript
  import { useErrorBoundary } from "react-error-boundary";

  function PostEditor() {
    const { showBoundary } = useErrorBoundary();

    async function saveBlogPost() {
      try {
        await fetch("...");
      } catch (e) {
        showBoundary("Could not save blog post");
      }
    }
    return ...;
  }
  ```
* Genau wie bei Error Boundaries, die beim Rendern aktiv werden, wir hier auch die n√§chsth√∂here `ErrorBoundary`-Komponente angezeigt

  </textarea
          >
        </section>

        <section>
          <h3>Exkurs: Error Boundary selbstgebaut</h3>
          <p class="fragment">
            <b>getDerivedStateFromError</b> und <b>componentDidCatch</b> werden
            von React im Fehlerfall aufgerufen
          </p>
          <pre
            class="fragment"
          ><code class="javascript" contenteditable data-trim>
              class ErrorHandler extends React.Component {
                constructor(props) {
                  super(props);
                  this.state = { error: null };
                }

                static getDerivedStateFromError(error) {
                  return { error: error.toString() };
                }

                componentDidCatch(error, info) {
                  console.error("uups... we caught an error", error, info);
                }

                render() {
                  if (this.state.error) {
                    return (
                      &lt;div>
                        &lt;h1>An error occured!&lt;/h1>
                        &lt;pre>{this.state.error}&lt;/pre>
                        &lt;button onClick={() => this.setState({ error: null })}>Try again&lt;/button>
                      &lt;/div>
                    );
                  }
                  return this.props.children;
                }
              }
            </code></pre>
        </section>

        <section>
          <h3>Exkurs: Error Boundary selbstgebaut</h3>
          <h4>Lifecycle</h4>

          <div style="display: flex">
            <pre><code class="javascript" contenteditable data-trim>
                  class ErrorHandler extends React.Component {
                    constructor(props) {
                      super(props);
                      this.state = { error: null };
                    }

                    static getDerivedStateFromError(error) {
                      return { error: error.toString() };
                    }

                    componentDidCatch(error, info) {
                      console.error("uups... we caught an error", error, info);
                    }

                    render() {
                      if (this.state.error) {
                        return (
                      &lt;div>
                         &lt;h1>An error occured!&lt;/h1>
                        &lt;pre>{this.state.error}&lt;/pre>
                        &lt;button onClick={() => this.setState({ error: null })}>Try again&lt;/button>
                      &lt;/div>
                        );
                      }
                      return this.props.children;
                    }
                  }
                </code></pre>

            <ol>
              <li class="fragment">
                Komponente wird instantiiert, Konstruktor aufgerufen, State
                vorbelegt (error = null)
              </li>
              <li class="fragment">
                Komponente wird gerendert. Da
                <code>this.state.error</code> nicht gesetzt ist, werden die
                Children gerendert
              </li>
              <li class="fragment">
                Fehler tritt in Unterkomponente beim Rendern auf
              </li>
              <li class="fragment">
                <code>componentDidCatch</code> wird aufgerufen (Fehler kann z.B.
                protokolliert werden)
              </li>
              <li class="fragment">
                <code>getDerivedStateFromError</code> wird aufgerufen und
                liefert einen neuen Teil-State zur√ºck. <br />(Andere Teile des
                States bleiben unver√§ndert)
              </li>
              <li class="fragment">
                Komponente wird erneut gerendert. Da
                <code>this.state.error</code> jetzt gesetzt ist, wird die
                Fehlermeldung angezeigt, inklusive des Buttons
              </li>
              <li class="fragment">
                Nach dem Klick auf den Button, wird
                <code>this.state.error</code> wieder auf null gesetzt
              </li>
              <li class="fragment">
                Komponente wird neu gerendert (durch <code>setState</code>). Da
                <code>this.state.error</code> wieder null ist, werden die
                Children erneut gerendert
              </li>
            </ol>
          </div>
        </section>

        <section data-markdown>
          <textarea data-template>
## Zustand (Bibliothek)

* Leichtgewichtige Bibliothek f√ºr globalen Zustand
* Sehr vereinfacht ausgedr√ºckt eine Art `useState` aber f√ºr globale Daten
* Verglichen mit Redux etwas einfacher. Sowohl was Verwendung, aber auch was Features angeht
---
### Zustand: Stores
* Die Daten werden in Stores gehalten
* Ein Store steht **au√üerhalb** der Komponentenhierarchie
  * Das ist √§hnlich wie z.B. bei Redux
* Wir k√∂nnen aus allen Komponenten direkt darauf zugreifen und die Daten darin ver√§ndern
* Komponenten, die auf den Store zugreifen, werden neu gerendert, wenn sich die Daten darin √§ndern...
  * ...und sie die **ge√§nderten** Daten verwenden
  * das ist anders als beim Context!
  * wir haben also feingranularere Updates
---
### Zustand: Stores
* Ein Store ist ein Objekt, das mit der `create`-Funktion angelegt wird
* An die `create`-Funktion √ºbergibst Du die sog. `initializer`-Funktion.
* Das ist eine Callback-Funktion, die daf√ºr verantwortlich ist, den initialen State zu erzeugen
* Bei der Verwendung mit TypeScript musst Du eine "Currying"-Variante von der `create`-Funktion √ºbergeben, damit du die Typ-Definition setzen kannst
* ```typescript

  type INotificationStore = {
    msg: string|null;
    hide(): void;
    show(msg: string): void
  }

  // Achtung () nach der Typ-Angabe nicht vergessen!
  const useStore = create<INotificationStore>()(
    (set) => ({
      msg: null,

      hide(messageId) {
        set({ msg: null });
      },
      show(msg) {
        set({ msg });
      },
    })
  );
  ```
* Wie wir den Store in unseren Komponenten verwenden, sehen wir in K√ºrze...
---
### Zustand: Stores
* Die `initializer`-Callback-Funktion liefert ein Objekt zur√ºck, dass den initialen Zustand des Stores enth√§lt
* Das Objekt kann sowohl Daten als auch `Actions` (Methoden) enthalten
* Mit den Methoden k√∂nnen Verwender des Stores die darin ver√§ndern
  * Es ist nicht m√∂glich, ohne eine Action die Daten zu ver√§ndern
  * Actions sind aber nicht dazu da, Daten aus dem Store zu _lesen_
* Ein Store ohne Actions ist daher m√∂glich, aber sinnlos:
* ```typescript
  type INotificationStore = {
    msg: string|null;
  }

  const useStore = create<INotificationStore>()(
    (set) => ({
      msg: null,
    })
  );

  // und nu'? Wir k√∂nnen die msg zwar lesen, aber nicht √§ndern...
  ```

---
### Zustand: Actions
* Um die Daten zu ver√§ndern, werden Actions verwendet
* Eine Action ist eine Methode in deinem Store, die von Komponenten aufgerufen werden kann und die ihrerseits neue Daten in den Store setzen kann
* Die Action-Methode kann beliebige Parameter entgegennehmen, so wie es f√ºr dich fachlich sinnvoll ist
* Eine Action-Methode kannst du als `async function` implementieren, wenn Du darin asynchronen Code unterbringen m√∂chtest
* In einer Action-Methode kannst Du beliebige Logik ausf√ºhren
* Um den Store mit neuen Daten zu versorgen, verwendest Du die `set`-Funktion, die an deine `initializer`-Funktion √ºbergeben wird
* ```tsx
  type CounterStore = { count: number; increaseBy(amount: number): void; resetTo(newCount: number): void }

  const counterStore = create<CounterStore>()( set => ({
    // count initial auf 0 setzen
    count: 0,

    resetTo(newCount) {
      set({ count: newCount });
    },

    increaseBy(amount) {
      // number erh√∂hen und in den State setzen
      set(currentState => ({ number: currentState.count + amount }),
    }
  })
  ```
---
### Zustand: set-Funktion
* Die set-Funktion kannst Du auf zwei Arten verwenden:
  1. Du √ºbergibst ihr einen neuen (Teil-Zustand)
  2. Du √ºbergibst ihr eine Callback-Funktion, √ºber die Du Zugriff auf den aktuellen Inhalt des Stores hast
* In beiden F√§llen lieferst du ein neues Objekt zur√ºck. Das neue Objekt wird dann mit dem bestehenden Inhalt deines Stores **gemerged**
* ```typescript
  // Beispiel: Mergen von Zustand
  type EmployeeStore = { name: string; sallary: number; updateSallary(n: number) => void }

  const employeeStore = create<EmployeeStore>()(set => ({
       name: "Klaus", sallary: 30000,
       updateSallary(newSallary: number) {
            // name wird NICHT ver√§ndert, nur sallary neu gesetzt
            set({sallary: newSallary});
       }
  });
  ```
---
### Zustand: set-Funktion
* Mit der Callback-Notation hast Du Zugriff auf die aktuellen Daten deines Stores
* Das ist z.B. n√ºtzlich, wenn Du Daten auf Basis bestehender Werte ver√§ndern m√∂chtest
* Oder zum Beispiel, wenn Du Pr√ºfungen mit den bestehenden Daten durchf√ºhren m√∂chtest
* ```typescript
  type EmployeeStore = { name: string; sallary: number; updateSallary(n: number) => void }

  const employeeStore = create<EmployeeStore>()(set => ({
       name: "Klaus", sallary: 30000,
       updateSallary(newSallary: number) {
            // sallary nur aktualisieren, wenn das neue Gehalt √ºber dem bisherigen liegt
            set(currentState => newSallary > currentState.sallary ? ({ sallary: newSallary }) : {});
       }
    )
  });
  ```
---
### Zustand: get-Funktion
* Um in einer Action auf den aktuellen Store zuzugreifen, gibt es noch eine andere M√∂glichkeit
* An die `initializer`-Funktion wird als zweiten Parameter eine `get`-Funktion geliefert.
* Diese liefert dir ebenfalls den kompletten Store zur√ºck. Dar√ºber kannst Du auch andere Actions ausf√ºhren
* ```typescript
  type EmployeeStore = {
            name: string;
            position: string;
            sallary: number;
            updateSallary(n: number) => void
            promoteToSenior(): void
  }

  const employeeStore = create<EmployeeStore>()( (set, get) => ({
       name: "Klaus", position: "junior", sallary: 30000,

       updateSallary(newSallary: number) {
            // sallary nur aktualisieren, wenn das neue Gehalt √ºber dem bisherigen liegt
            const currentSallary = get().sallary;

            if (newSallary > currentSallary) {
              set({sallary: newSallary });
            }
       },
       promotoToSenior() {
            // Neue Position setzen
            set({ position: "senior" });

            // ggf. Gehalt erh√∂hen
            get().updateSallary(600000);
       }
    )
  });
  ```
---
### Arbeiten mit dem Store
* Die `create`-Funktion liefert eine (Hook-)Funktion zur√ºck, die Du in einer Komponente verwenden kannst, um mit dem Store zu kommunizieren
* Der Hook-Funktion √ºbergibst Du eine Callback-Funktion, die `selector` hei√üt, weil Du damit die Teile aus dem Store ausw√§hlst, die deine Komponente ben√∂tigt
  * Damit kannst Du zwar auch den ganzen Store ausw√§hlen, du solltest aber wirklich immer nur das ausw√§hlen, was Du auch brauchst
  * (√Ñhnlich wie in einer Datenbank, in der Du nur die Spalten einer Tabelle w√§hlst, die du f√ºr deine Aufgabe ben√∂tigst)
* ```typescript
  function SallaryWidget() {
    const sallary = useEmployeeStore( s => s.sallary );
    return <div>Your current sallary: {sallary}</div>
  }
  ```
* In diesem Fall wird die Komponente nur neu gerendert, wenn sich das `sallary` √§ndert.
  * Wenn sich z.B. die `position` √§ndern w√ºrde, wird die Komponente nicht neu gerendert
---
### Arbeiten mit dem Store: Change Detection
* Um zu ermitteln, ob eine Komponente nach √Ñnderungen an einem Store neugerendet werden muss, vergleicht Zustand **die R√ºckgabewerte der Selektor-Funktion**
* Das passiert auf **Referenz-Ebene**.
  * Deswegen musst Du sehr vorsichtig sein, was du zur√ºcklieferst
  * Im Zweifel einfach mehrfach die Hook-Funktion aufrufen und die Daten einzeln ausw√§hlen
* Beispiele:
* ```typescript
  // Komponente wird immer neugerendert, wenn sich das Sallary im Store √§ndern (sonst nicht)
  const sallary = useEmployeeStore(s => s.sallary);

  // Komponente nur neu rendern, wenn Sallary ge√§ndert wird und √ºber 500000 liegt
  // bzw. vorher √ºber 500000 lag und jetzt darunter
  const hasHighSallary = useEmployeeStore( s => s.sallary > 500000 );

  // Komponente wird neu gerendert, wenn sich entwender sallary und/oder exchangeRate ge√§ndert haben
  //  und die Berechnung dadurch einen neuen Wert zur√ºckliefert
  const sallaryInDollar = useEmployeeStore( s => s.sallary * s.exchangeRate );
  ```

---
### Shallow Vergleiche
* Werte, die Du aus dem Store ausw√§hlst werden mit `Object.is` verglichen
  * Das ist im Wesentlichen ein Vergleich von Referenzen
* ```typescript
  const s1 = "a";
  const s2 = "a";
  Object.is(s1, s2); // true

  const n1 = 100;
  const n2 = 100;
  Object.is(n1, n2); // true

  // Achtung bei Objekten und Array!
  const person1 = { firstname: "Klaus" };
  const person2 = { firstname: "Klaus" };
  Object.is(person1, person2); // false
  Object.is(person1, person1); // true

  const cities1 = ["Hamburg", "Berlin"];
  const cities2 = ["Hamburg", "Berlin"];
  Object.is(cities1, cities2); // false
  ```
* Wenn Du **Objekte** oder **Arrays** aus dem Store ausw√§hlst, kann das schnell dazu f√ºhren, dass
            deine Komponente zu h√§ufig neugerendert wird:
* ```typescript
  // Rendert jedesmal (!) wenn sich irgendetwas (!) im Store ver√§ndert,
  // da jedesmal (!) liefert die Selektor-Funktion ein neues (!) Objekt
  // zur√ºck (Object.is ist also immer false)
  const sallaryAndPosition = useEmployeeStore(s => ({ sal: s.sallary, p: s.position )} )
  ```
* Dieses Problem kannst Du auch zwei Arten umgehen
  1. Du kannst [useShallow](https://docs.pmnd.rs/zustand/guides/prevent-rerenders-with-use-shallow) verwenden
  2. Du kannst mehrere Selektoren definieren
---
### Ausw√§hlen mit useShallow
* Mit [useShallow](https://docs.pmnd.rs/zustand/guides/prevent-rerenders-with-use-shallow) f√ºhrt Zustand einen "shallow"-Vergleich durch
* Dann wird nicht die Referenz des zur√ºckgegebenen Objektes verglichen sondern, dessen Eigenschaften/Werte auf oberste Ebene im Objekt/Array
* ```typescript
  // useShallow f√ºhrt zu shallowEqual-Vergleich
  // hier wird s.sallary und s.position jeweils mit Object.is verglichen
  // Nur wenn einer der Aufrufe false ergibt, wird die Komponente neu gerendert
  const sallaryAndPosition = useEmployeeStore(useShallow(s => ({ sal: s.sallary, p: s.position )}));
  ```
* "Nur auf oberste Ebene" bedeutet, dass bei verschachtelten Objekten/Arrays √Ñnderungen unterhalb *nicht* erkannt werden:
* ```typescript
  // Store sieht z.B. so aus:
  const contactStore = {
    address: {
      city: "Hamburg"
    }
    email: "klaus@example.de"
  }

  const address = useContactStore(useShallow(s => ({ address: s.address, email: s.email })));
  ```
---
### Ausw√§hlen mit mehreren Selektoren
* Du kannst das Problem mit Referenzen und `useShallow` umgehen, in dem Du einfach mehrere useStore-Aufrufe verwendest,
            die jeweils primitive Typen ausw√§hlen (bzw. solche Werte, die stabile Referenzen haben, wie actions z.B.)
* ```typescript
  // Diese ausgew√§hlten Werte k√∂nnen alle problemlos und zuverl√§ssig mit "Object.is" verglichen werden:
  const sallary = useEmployeeStore(s => s.sallary);
  const position = useEmployeeStore(s => s.position);
  const promoteToSenior = useEmployeeStore(s => s.promoteToSenior);
  ```            
---
### Arbeiten mit dem Store: Actions ausf√ºhren
* Actions w√§hlst du auf dieselbe Art aus, wie Daten. Es gelten die selben Regeln.
* Dann kannst Du sie wie normale Funktionen in deiner Komponente verwenden
* ```typescript
  function PromoteButton() {
    const isSenior = useEmployeeStore( s => s.position === 'senior' );
    const promoteToSenior = useEmployeeStore( s => s.promoteToSenior );

    return <button disabled={isSenior} onClick={ () => promoteToSenior() }>
            Promote me to senior!
            </button>
  }
  ```
---
## √úbung: Zustand Basics
* *Stelle den `NotificationContext` auf Zustand um*
  * Doku: https://docs.pmnd.rs/zustand/getting-started/introduction
* Bitte arbeite im Verzeichnis `30_zustand_intro/workspace`
  * Dort `npm install` und `npm start` ausf√ºhren (alten npm-Prozess ggf. beenden)
* Der Stand dort entspricht dem "fertigen" Stand aus dem Context-Teil mit fertigem `NotificationContext`
* Stelle `NotificationContext` auf einen Zustand-Store um (Verhalten soll gleich bleiben) und verwende den Store dann in `NotificationApp`
*   TODOs findest Du in `NotificationContext.tsx` und `NotificationApp.tsx`
* Eine L√∂sung findest Du in `material/02_solution_zustand_intro`
* Bei Fragen: fragen üòä
* Wenn Du fertig bist, bitte die Hand heben ‚úã
---
### Konsequenzen bzw. √Ñnderungen gegen√ºber dem Context
* Wir k√∂nnen mit "abgeleiteten" Daten arbeiten, das verhindert Redundanzen
  * `message` z.B. braucht **nicht** mehr im Store zu sein, weil wir jedesmal √ºber `messageId` und `lang` die "fertige" Message ausw√§hlen k√∂nnen
* Wir sparen durch die Selektoren Renderzyklen
* Im Gegensatz zu Context ist der Store immer global.
  * Context kann auch in einer Teil-Hierarchie der Anwendung verwendet werden
  * Das geht mit Zustand zwar auch, aber nur umst√§ndlich: https://docs.pmnd.rs/zustand/guides/initialize-state-with-props
---
### "Berechnete" Daten
* Wir haben bei den Selektoren gesehen, dass Du nicht unbedingt die "Rohdaten" aus dem Store ausw√§hlen musst
* Du kannst auch "berechnete" oder "abgeleitete" Daten ausw√§hlen
* ```typescript
  const isSenior = useEmployeeStore( s => s.position === 'senior' );
  ```
* Damit kannst Du das Rendering deiner Anwendung optimieren (Re-renderings einsparen)
* ü§î Wo macht das in unserem `NotificationStore` Sinn?  ü§î
* ü§î Welche Alternativen gibt es zur Auswahl direkt in einer Komponente? ü§î
* ü§î Wann w√§ren Custom Hooks sinnvoll? ü§î
  * Beispiel: Die `messageId` in unserem Store ist prinzipiell f√ºr jeden einsehbar
  * Das k√∂nnen wir zwar nicht √§ndern, aber mit einem Custom Hook (z.B. `useNotificationMessage`) w√§re es klar(er),
            dass die Message nicht direkt ermittelt werden kann bzw. muss
  * Man k√∂nnte z.B. als Konvention festlegen, dass Daten aus einem Store **immer** nur per Custom Hook ausgew√§hlt werden? ü§î
  * Man k√∂nnte einen Custom Hook bauen, der alle **Actions** eines Stores liefert? Warum? ü§î
---
### Testen von Zustand-Stores
* Du kannst deine Anwendung wie gewohnt mit Jest/Vitest und Testing Library testen
* Du kannst entweder Komponenten testen, die den Store benutzen oder die Store-Hook-Funktionen oder deine Custom Hook-Funktionen
* ‚ö†Ô∏è Beim Test musst du bedenken: **der Store ist global** und wird **nicht zur√ºckgesetzt *zwischen* einzelnen Tests**!
* ```typescript
  test("01 initial", async () => {
    render(<NotificationApp />);

    // ‚ö†Ô∏è  Initial State: "Keine Notification" sichtbar (messageId: null)
    expect(
      screen.getByRole("heading", { name: /Keine Notification/i }),
    ).toBeInTheDocument();

    await user.click(screen.getByRole("button", { name: /not_found/i }));

    // Im Store ist jetzt messageId auf 'not_found' gesetzt...
  });

  test("02 second", async () => {
    render(<NotificationApp />);

    // ‚ö†Ô∏è  Da der Store nicht zur√ºckgesetzt wird,
    //     ist "Keine Notification" hier NICHT sichtbar,
    //     wenn beide Tests hintereinander ausgef√ºhrt werden, ist dieser Test daher "rot"
    // ‚ö†Ô∏è  Wenn dieser Test einzeln ausgef√ºhrt wird, ist er "gr√ºn", weil der Store
    //     dann den Initial-State hat
    expect(
      screen.getByRole("heading", { name: /Keine Notification/i }),
    ).toBeInTheDocument();
  });
  ```
---
### Testen: Zur√ºcksetzen des States
* Du solltest nach (oder bevor) einem Test den State wieder auf dessen initial Zustand setzen
* Dazu kannst Du die Funktion `getInitialState` verwenden, die auf deinem Store definiert ist
* ```typescript
  act(() =>
    useNotificationStore.setState(useNotificationStore.getInitialState()),
  );
  ```
* Das kannst Du in einer `beforeEach` oder `afterEach`-Funktion machen
* In der Zustand Doku [ist beschrieben](https://docs.pmnd.rs/zustand/guides/testing#setting-up-zustand-for-testing) wie du
            das automatisiert f√ºr *alle* deine Stores nach **allen** Tests automatisch tun kannst
  * Je nach Anwendungsfall w√ºrde ich mich entscheiden, ob sich der Aufwand lohnt, oder man es manuell zur√ºcksetzt
---
### Testen: Manipulieren des States
* Du kannst im Test die Actions deines Stores aufrufen, um die Daten im Store zu √§ndern
* Damit kannst Du das korrekte Verhalten deines Stores √ºberpr√ºfen
* Um Daten au√üerhalb der Actions zu √§ndern, kannst Du die `setState`-Funktion verwenden, die
  auf jedem Store definiert ist
* Damit kannst du √Ñnderungen noch isolierter testen (z.B. ob eine Komponente neu gerendert wird, unabh√§ngig davon, auf welchem Weg die Daten ver√§ndert werden)
* Der `setState`-Funktion √ºbergibst Du eine Untermenge des States.
* Die √ºbergebenen Daten werden mit dem bestehenden State zusammengef√ºhrt (analog zur `set`-Funktion in einer Action)
* ```typescript
  act(() =>
    useNotificationStore.setState({
      lang: "de",
    }),
  );
  ```
* Mit `getState` kannst Du dir jederzeit den aktuellen State abfragen
* Mit `getInitialState` bekommst Du jederzeit den initialen State
* ```typescript
  const currentState = useNotificationState.getState();
  const initialState = useNotificationState.getInitialState();
  ```
* Diese Funktionen stehen dir nat√ºrlich auch au√üerhalb von Tests zur Verf√ºgung.
---
### Testen deiner Hooks
* Den `useXyzStore`-Hook bzw. deine Custom Hooks kannst Du wie gewohnt testen
* Auch hier gilt: der Store ist global und du musst ihn nach dem testen zur√ºcksetzen
* ```typescript
  test("01 useMessage test", async () => {
    const { result } = renderHook(() => useNotificationMessage());

    expect(result.current).toBeNull();

    act(() =>
      useNotificationStore.setState({
        messageId: "not_found",
      }),
    );

    // useNotificationMessage liefert die √ºbersetzte Message zur√ºck...
    expect(result.current).toBe("Not found");

    // Sprache √§ndern...
    act(() =>
      useNotificationStore.setState({
        lang: "de",
      }),
    );

    expect(result.current).toBe("Nicht gefunden");

  });

  ```
---
### √úbung: Testen eines Zustand Stores
* **Schreibe Tests f√ºr deinen Store**
* √úberlege dir, was sinnvolle Tests w√§ren
* W√§hle die Teststrategie, die dir am meisten zusagt
  * Du kannst eine Komponente testen, die den Store verwendet
  * und/oder Du kannst die Hooks direkt testen
*
  </textarea
          >
        </section>

        <section>
          <h3>Testen von fetch-Aufrufen</h3>
          <p>Herausforderungen:</p>
          <ul>
            <li>Asynchroner Code (nicht beschr√§nkt auf fetch)</li>
            <li>Server Zugriffe/Server Mocks</li>
          </ul>
        </section>
        <section>
          <h3>Behandlung von asynchronem code</h3>
        </section>

        <section>
          <h3>Testen von asynchronem Code</h3>
          <p>
            Beispiel: Die <b>App</b> Komponente l√§dt Daten,
            <em>erst dann</em> stellt sie die PostList dar. Das Laden der Posts
            ist asynchron.
          </p>

          <pre><code class="javascript">
            it("should render posts read from backend", () => {
              render(&lt;App />);

              // Annahme: es gibt einen Artikel mit dem Title "Learning React"
              const articleOne = screen.findByRole("heading", { name: "Learning React" });

              expect(articleOne).toBeInTheDocument(); // THIS WON'T WORK!
            });
          </code></pre>
          <p>
            Wir k√∂nnen einen Test als async-funktion schreiben und darin mit
            <b>await</b> auf ein Element warten
          </p>
          <pre><code class="javascript">
            // Test-Funktion als async-Funktion (beachte 'async'):
            it("should render posts read from backend", async () => {
              render(&lt;App />);

              // Beachte await hier:
              const articleOne = await screen.findByRole("heading", { name: "Learning React" });

              expect(articleOne).toBeInTheDocument(); // YIPPIE, WORKS
            });
          </code></pre>
          <p>
            Achtung! Ihr m√ºsst <code>find</code> Query-Funktionen verwenden, da
            die <code>get</code>-Funktionen davon ausgehen, dass ein Element
            bereits vorhanden ist, und nicht noch darauf warten.
          </p>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Testen von fetch</h3>
          <p>Wie gesehen, k√∂nnen wir asynchronen Code testen</p>
          <p>Wollen wir fetch-Aufrufe in unserem Code haben, den wir testen?</p>
          <p>
            M√∂glicherweise nicht, weil wir bei echten fetch-Aufrufen auch einen
            echten, laufenden und funktionierenden Server im Test br√§uchten
          </p>
          <p>Stattdessen wollen wir das "echte" fetch mocken</p>
        </section>

        <section>
          <h3>Fetch mocken, Ansatz #1</h3>
          <p>Wir k√∂nnen <b>komplette Module</b> in Jest mocken</p>
          <p>
            Wir k√∂nnten unseren fetch-Code in ein eigenes Modul schieben und das
            dann mocken
          </p>

          <pre><code class="javascript">
            // api.ts (fetch vereinfacht!)
            export function readPosts() {
              return fetch("http://localhost:7000/posts").then(response => response.json());
            }
          </code></pre>

          <pre><code class="javascript">
            // App.tsx:

            import { readPosts } from "./api";
            function App() {
              // ...
              React.useEffect(() => {
                // Verwenden von readPosts hier:
                readPosts()
                  .then(json => {
                    setLoading(false);
                    setPosts(json);
                  })
                  .catch(err => console.error("Loading data failed: " + err));
              }, []);
            }
          </code></pre>
        </section>
        <section>
          <h3>Mocken von Modulen in Jest</h3>
          <p>Es gibt mehrere Varianten. Das hier die einfachste(?)</p>

          <pre><code class="javascript">
            // App.test.tsx

            const mockPosts = [
              { id: "1", title: "One Fetch Mock", body: "Lorem ipsum" },
              { id: "2", title: "Second Post Fetch Mock", body: "Some more content" }
            ];

            jest.mock("../api", () => ({
              readPosts: () => Promise.resolve(mockPosts)
            }));

            it("should render posts read from backend", async () => {
              render(&lt;App />);

              // Hier immer noch asnychroner Code (deswegen await), aber:
              // kein laufender Server mehr ben√∂tigt
              const articleOne = await screen.findByRole("heading", { name: "One" });
              expect(articleOne).toBeInTheDocument();

              expect(screen.getByText("Second Post")).toBeInTheDocument();
            });
          </code></pre>
          <p>
            Beispiel:
            <code
              >blog-example/steps/6a-testing-with-api-module/src/__tests__/App_module_mock.test.tsx</code
            >
          </p>
        </section>
        <section>
          <h3>Ansatz #2: fetch API mocken</h3>
          <p>Es gibt mehrere Bibliothken mit fetch-Mocks</p>
          <p>
            F√ºr mich funktioniert
            <a
              href="https://www.npmjs.com/package/jest-fetch-mock"
              target="_blank"
              >jest-fetch-mock</a
            >
            am Besten
          </p>

          <pre><code class="javascript">
            // App.test.tsx
            it("should render posts read from backend", async () => {
              // setzen des Ergebnisses, das der n√§chste fetch-Aufruf zur√ºckliefern soll
              fetchMock.mockResponse(JSON.stringify(mockPosts));

              render(&lt;App />);

              // Immer noch asynchroner Code, aber kein "echter" fetch-Aufruf mehr,
              // zur√ºckgegeben wird das oben angegebene Ergebnis
              const articleOne = await screen.findByRole("heading", { name: "One Fetch Mock" });

              expect(articleOne).toBeInTheDocument();
            });

          </code></pre>
          <p>
            Beispiel:
            <code
              >blog-example/steps/6a-testing-with-api-module/src/__tests__/App_jest_mock.test.tsx</code
            >
          </p>
        </section>

        <section data-markdown>
          <textarea data-template>
### jest-fetch-mock

* `fetchMock.mockResponse`: Ersetzt *alle* Aufrufe mit dem √ºbergebenen Ergebnis
* `fetchMock.mockResponseOnce`: Ersetzt nur den n√§chsten Aufruf mit dem √ºbergebenen Ergebnis
* `fetchMock.mockResponses`: Ersetzt die n√§chsten X Aufrufe mit den √ºbergebenen Ergebnissen
* Alle Funktionen haben dieselbe Signatur:
  * Entweder ihr setzt direkt das Ergebnis, das zur√ºckgeliefert werden soll
  * Oder ihr gebt eine Callback-Funktion an, die ein `Promise` mit der gew√ºnschten Ergebnis zur√ºckliefert
* Wenn ihr das Ergebnis direkt setzt, k√∂nnt ihr zwei Parameter √ºbergeben:
  1. Den Body, der zur√ºckgeliefert werden soll Achtung! String kein Objekt! (ggf.`JSON.stringify()` verwenden)
  2. Ein Objekt mit init-Parametern, mit dem ihr z.B. den Status setzen k√∂nnt
  * siehe dazu [API Dokumentation der Response Funktion](https://developer.mozilla.org/en-US/docs/Web/API/Response/Response)
* ```
  const mockPosts = [ { title: "Hello", body: "World"} ];
  // liefert HTTP 200 OK zur√ºck f√ºr alle folgenden fetch-Aufrufe zur√ºck:
  fetchMock.mockResponse(JSON.stringify(mockPosts));
  ```
* ```
const mockResponse = { id: "100", title: "Hello", body: "World", createdAt: "2022-09-06"};
// liefert HTTP 201 CREATED f√ºr den n√§chsten fetch-Aufrufe zur√ºck:
fetchMock.mockResponse(JSON.stringify(mockResponse), { status: 201 });
```


          </textarea>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Ansatz #3: Mock Service Worker (MSW)</h3>

          <p><a href="https://github.com/mswjs/msw" target="_blank">MSW</a></p>
          <p>
            MSW mockt echte Server-Aufrufe mit einem
            <a
              href="https://developer.mozilla.org/de/docs/Web/API/Service_Worker_API"
              >Service Worker</a
            >
          </p>
          <p>
            fetch-Aufrufe werden "richtig" ausgef√ºhrt, aber beantwortet von dem
            Service Worker Mock
          </p>

          <pre><code class="javascript">
            // PostList.test.js
            import { rest } from 'msw'
            import { setupServer } from 'msw/node'

            const server = setupServer(
              rest.get('/posts', (req, res, ctx) => {
                return res(ctx.json( mockPosts ))
              }),
            )

            test("it should render blog list", async () => {
              render(&lt;PostList />);
              // ...
            })
          </code></pre>
        </section>
        <section data-markdown>
          <textarea data-template>
# Immutable DAten
* In React funktioniert viel (Change Detection) √ºber immutable Daten
* Welche M√∂glichkeiten gibt es in JavaScript?
* Wie hilft `immer`?
<!-- .element: class="todo" -->aus anderen Schulungen √ºbernehmen
# Globales Zustandsmanagement

* √úbersicht was gibt es?
* Woran interscheiden sich die Tools
  * REdux auch Logik, alle anderen "eher" nur State
* Zustand

  </textarea
          >
        </section>

        <!-- ============================================================================= -->

        <section data-markdown>
          <textarea data-template>
# Suspense
<!-- .element: class="todo" -->"State of the Art": Suspense (am Beispiel TanStack Query)
<!-- .element: class="todo" -->TS Query Teil entschlacken, Fokus auf Suspense, evtl. mit Transitions (das w√§re dann auch concurrent mode)
<!-- .element: class="todo" -->error boundaries (Teil 1: was sind EBs -> Fehler beim Rendern (!!!), Teil 2: mit Suspense)

---            
<!-- .slide: id="t-tanstack-query" -->            
# Mordernes Data Fetching in React
---
## Modernes Data Fetching in React
* Mit `useEffect`, `fetch` und `axios` stehen dir "Low-Level-APIs" zur Verf√ºgung, um mit serverseitigen Daten zu arbeiten
* Diese APIs sind React (`useEffect`) bzw. Browser (`fetch`) Standard APIs
* Es gibt aber spezialisierte Bibliotheken, die das Arbeiten mit Daten erleichtern k√∂nnen.
  * [TanStack Query](https://tanstack.com/query/latest) / und [Vercel SWR](https://swr.vercel.app/): Zwei Bibliotheken zum Laden/Speichern von Daten inklusive Cache-Funktion
  * [Redux Toolkit Query](https://redux-toolkit.js.org/rtk-query/overview): Arbeiten mit APIs in Redux-Anwendungen
  * [Apollo GraphQL Client](https://www.apollographql.com/docs/react/): Client f√ºr GraphQL APIs mit Cache und Statemanagement M√∂glichkeiten
* Diese Bibliotheken haben alle √§hnliche Konzepte:
  * Hooks zum Laden/Speichern von Daten
  * globales Caching von Daten (auch zur Sicherstellung der konsistenten Darstellung)
    * Strategien zur Aktualisierung von Daten (auch automatisch im Hintergrund)
---
## TanStack Query
### Schritt-f√ºr-Schritt: Laden von Daten mit "TanStack Query"

* üëâ `PostListPage`
* üëâ sp√§ter: `PostEditorPage`
* üëâ sp√§ter: Custom Hooks 
* üëâ sp√§ter: zod
* üëâ Arbeiten in `advanced/workspace`


---
### Der QueryClient

* Zentrales Konfigurationsobject: `QueryClient`
* React-unabh√§ngig
* Wird beim Starten der Anwendung initialisiert
* Oft reichen Default-Einstellung
* Es k√∂nnen aber z.B. globale Refetch-Policies eingestellt werden
* Das Objekt wird per QueryClientProvider in die Anwendung gereicht
* ```typescript
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: {
        refetchOnWindowFocus: false
      }
    }
  });

  root.render(
    <QueryClientProvider client={queryClient}>
      <App />
    </QueryClientProvider>
  );
  ```

---
### Laden von Daten: useQuery

* [Queries](https://tanstack.com/query/latest/docs/react/guides/queries) werden mit dem `useQuery`-Hook ausgef√ºhrt
* [Der `useQuery`-Hook](https://tanstack.com/query/latest/docs/framework/react/reference/useQuery) erwartet ein Konfigurationsobjekt
  * `queryKey`: Array mit Query Keys (zur Interaktion mit dem Cache)
  * `queryFn`: Funktion zum Laden der Daten
  * Weitere Konfigurationen (optional)
* ```typescript
  import { useQuery } from "react-query";
  import { loadBlogPosts } from "./blog-api";
  function BlogListPage() {

    const result = useQuery({queryKey: ['posts'], queryFn: loadBlogPosts});

    // ...
  }
  ```
---
### Query Function

* `useQuery` erwartet eine [Query-Function](https://tanstack.com/query/latest/docs/react/guides/query-functions), die den eigentlichen Request ausf√ºhrt
* Die Signatur ist fast beliebig, die Funktion muss aber ein Promise zur√ºckliefern:
* Wenn die Daten erfolgreich geladen wurden, muss das Promise mit den Daten "aufgel√∂st" werden
* Wenn es einen Fehler gab, muss die Funktion einen Fehler werfen
* ```typescript
  // async function gibt IMMER ein Promise zur√ºck
  export async function loadBlogPost(postId) {
    const response = await fetch("http://localhost:7000/posts" + postId);

    if (!response.ok) {
      throw new Error("Could not load blog post: " + response.status);
    }

    return response.json();
  }
  ```

---

### R√ºckagebwert von `useQuery` (Query Ergebnis)

* `useQuery` liefert ein Objekt zur√ºck:
  * `isLoading`: Der Query l√§dt noch (und es sind keine Daten im Cache)
  * `isSuccess`: Daten sind geladen
  * `isError`: Es ist ein Fehler aufgetreten
  * `data` enth√§lt die geladenen Daten
  * `error`: Fehlerobjekt aus der Query-Funktion 
* Weitere [siehe Doku](https://tanstack.com/query/latest/docs/react/reference/useQuery)
  
---
### Query Keys

* Mit den [Query Keys](https://tanstack.com/query/latest/docs/react/guides/query-keys) wird ein Ergebnis im Cache gespeichert
* Ein Query Key besteht aus einem Array von Werten
* √úblicherweise ist es ein Name (z.B. "posts") und dann ggf. weitere Parameter, zum Beispiel die Id eines Posts ("P1")
  oder die Sortierreihenfolge
  * Also alle Daten, die den Query exakt beschreiben
* ```typescript
  import { useQuery } from "react-query";
  import { loadBlogPosts } from "./blog-api";

  function BlogPage({blogPostId}) {

    // F√ºr jeden Aufruf mit einer neuen blogPostId
    //  wird das Ergebnis separat in den Cache gelegt
    const result = useQuery({
      queryKey: ['blogPost', blogPostId], 
      queryFn: () => loadPost(blogPostId)
    });

    // ...
  }
  ```
* Wenn ein Query mit denselben Query Keys in mehr als einer Komponente ausgef√ºhrt wird
* stellt TanStack Query sicher, dass der Query nur einmal ausgef√ºhrt wird
* wenn sich das Ergebnis √§ndert, werden alle Komponenten, die den Query verwenden,
automatisch aus dem Cache aktualisiert
* üëâ dieses Verhalten sehen wir uns sp√§ter noch an

---
## √úbung: Daten lesen mit TanStack Query

* **Vorbereitung**
* Workspace in der IDE √∂ffnen: `react18-training/advanced/workspace`
* Schritt 1: Backend starten
  * ```bash
  cd react18-training/blog-example/backend-rest
  npm start
  ```
  * Danach sollte unter [http://localhost:7000/posts](http://localhost:7000/posts) 
die Liste mit den (JSON-)Posts zur√ºckkommen
* Schritt 2: Frontend (Vite) starten
  * ```bash
  cd react18-training/advanced/workspace
  npm start
  ```
  * Die Anwendung sollte auf [http://localhost:3000](http://localhost:3000) laufen
  * Die Anwendung benutzt noch `useEffect` und `fetch`... das wollen wir √§ndern!
---
### √úbung: Daten lesen mit TanStack Query

* In der Komponente `PostListPage` wird `fetch` bzw. `useEffect` zum Laden der Daten verwendet
* Stelle diese Komponente auf `useQuery` um.
* Zeige eine Warte-Meldung an, w√§hrend die Daten geladen werden
  * Du kannst den Request k√ºnstlich langsam machen, in dem Du an die Url `?slow` h√§ngst
* TanStack Doku: 
  * [Queries](https://tanstack.com/query/v5/docs/framework/react/guides/queries)
  * [useQuery](https://tanstack.com/query/v5/docs/framework/react/reference/useQuery)
* M√∂gliche L√∂sung: `steps/10_useQuery`

---
### TanStack Query: Mutations

* [Mutations](https://tanstack.com/query/latest/docs/framework/react/guides/mutations) werden verwendet, um Daten zu *ver√§ndern* (speichern, l√∂schen)
* Der entsprechende Hook hei√üt [`useMutation`](https://tanstack.com/query/latest/docs/framework/react/reference/useMutation)
* Dessen API ist vergleichbar mit `useQuery`
* Auch der `useMutation`-Hook liefert Informationen √ºber den Zustand der Mutation zur√ºck
* ```typescript
  import { useMutation } from "react-query";
  import { savePost } from "./blog-api";

  function PostEditorPage() {
    const mutation = useMutation({
      mutationFn: savePost,
      onSuccess() {
        // optional: wird aufgerufen, wenn die Mutation erfolgreich war
        // ...
      }
    });

    if (mutation.status === "error") {
      return <h1>Error!</h1>;
    }

    if (mutation.status === "loading") {
      return <h1>Saving, please wait!</h1>;
    }

    // ...
  }
  ```
---
### TanStack Query: Mutations  
* Im Gegensatz zu `useQuery` wird eine Mutation aber nicht automatisch ausgef√ºhrt, sondern wird explizit gestartet
* Dazu liefert `useMutation` die Funktion `mutate` zur√ºck
* √úbergeben wird der Funktion die zu schreibenden Daten
* ```typescript
  const mutation = useMutation(/* ... */ );

  function saveBlogPost(newPost: NewBlogPost) {
    mutation.mutate(newPost);
  }
  ```
---
### Parameter f√ºr die Mutations
* √úblicherweise ben√∂tigt eine Mutation Daten, die erst bei der Ausf√ºhrung `mutate` feststehen
* Dazu kann der `mutate`-Funktion genau **ein** Parameter √ºbergeben werden
* Wie dieser aussieht bestimmt ihr in der Definition der Mutation selbst
* Dieser Parameter entspricht n√§mlich dem ersten Parameter der `mutationFn`:
  * ```typescript
    const addPostMutation = useMutation({
      mutationFn(newBlogPost: NewBlogPost) { /* ... */ }
    })
    ```
* Wenn ihr mehr als einen "logischen" Parameter ben√∂tigt, m√ºsst ihr ein Objekt verwenden:
* ```typescript
  type AddCommentParam = { postId: string, comment: string };

  const addCommentMutation = useMutation({
    mutationFn(param: AddCommentParam) {
      const url = `/api/posts/${postId}/comments;
      fetch(url, { 
        body: JSON.stringify({comment: param.comment})
      });
    }
  });
  ```

---
### Arbeiten mit dem Ergebnis

* Wenn eine Mutation ausgef√ºhrt wurde, bekommt ihr `data` bzw. `error` zur√ºck
* Damit k√∂nnt ihr - wie bei `useQuery` - nach der Ausf√ºhrung einer Mutation die UI aktualisieren, um zum Beispiel Fehlermeldungen anzuzeigen
* ```typescript
  function PostEditor() {
    const savePostMutation = useMutation(/*...*/);

    return <form>
      { /* ... */}

      {saveMutation.isError && <p>Fehler beim Speichern des Posts: {String(saveMutation.error)}</p>}
      {saveMutation.isSuccess && <p>Der Blogpost wurde erfolgreich gespeichert!</p>}
    </form>
  }
  ```
---
### Auf das Ergebnis warten
* Um direkt nach Beendingung einer Mutation weitere Aktionen auszuf√ºhren, kann man `on`-Callback-Funktionen bzw. [`mutateAsync`](https://tanstack.com/query/latest/docs/framework/react/guides/mutations#promises) verwenden
* `onSuccess` und `onFailure` k√∂nnt ihr bei `useMutation` angeben. Das ist sinnvoll f√ºr Aktionen, die immer ausgef√ºhrt werden sollen
  * Sehen wir sp√§ter noch im Zusammenhang mit Caching.
* Mit `mutateAsync` k√∂nnt ihr _in einer Komponente_ auf das Ergebnis der Mutation warten. Das ist sinnvoll, wenn man Komponenten-spezfische Aktionen ausf√ºhren m√∂chte.
* `mutateAsync` liefert ein Promise mit den Daten der Mutation zur√ºck.
* Schl√§gt die Mutation fehl, wird das Promise nicht verworfen (rejected)
* Beispiel:
* ```typescript
  function PostEditor() {
    const navigate = useNavigate(); // vom React Router

    const savePostMutation = useMutation({ /* ... */ });

    async function savePost(newPost: NewPost) {
      const result = await savePostMutation.mutate(newPost);
      // result ist hier das Ergebnis der (erfolgreichen) Mutation

      navigate("/"); // nach erfolgreicher Mutation zur√ºck auf die Landingpage
    }

    // ...

  }
  ```


---
### Zur√ºcksetzen einer Mutation

* Wenn eine Mutation ausgef√ºhrt wurde, ist `status`, `data`, `error` usw. gesetzt
* Mit `reset` kann man diese Informationen zur√ºcksetzen
* Das kann zum Beispiel nach einem Fehler sinnvoll sein, um die Fehlermeldung wieder verschwinden zu lassen
  * Zum Beispiel nach einer Benutzer-Interaktion
* Dann ist die Mutation "wie neu"
* ```typescript
  function PostEditor() {
    const addPostMutation = useMutation(/* ... */);

    return <form>
      { /* ... */ }

      <input onChange={e => {
        addPostMutaton.reset();
        // ...
      }} />

      { /* ... */ }
    </form>
  }
  ```



---
## √úbung: Neue Blogposts auf den Server schreiben

* Die `PostEditor`-Komponente verwendet noch `fetch` um den neuen BlogPost zu speichern
* Stelle die Komponente auf TanStack Query bzw. den `useMutation`-Hook um
* Wenn die Mutation erfolgreich war und der Blogpost gespeichert wurde, soll die Landing-Page (`/`) gerendert werden
  * Das entspricht dem bisherigen Verhalten, der Code mit `useNavigate()/navigate` ist bereits in der Komponente
  * Der neue Post wird dort erst nach einem manuellen Refresh der Seite angezeigt. Das optimieren wir sp√§ter.
* Optional: Wenn es einen Fehler gibt, soll eine Fehlermeldung ausgegeben werden
  * Du kannst Fehler beim Speichern provozieren, in dem Du einen Titel eingibst, der k√ºrzer als f√ºnf Zeichen lang ist
* Optional: Wenn es einen Fehler gab und der Benutzer danach etwas in eines der Textfelder eingibt, soll die Fehlermeldung wieder verschwinden
* M√∂gliche L√∂sung `steps/20_useMutation`
---
## Custom Hooks
* Custom Hooks sind "normale" JavaScript/TypeScript-Funktionen, die aber andere (React-) Hooks (z.B. `useState`) verwenden k√∂nnen
* Custom Hooks k√∂nnen f√ºr Code verwendet werden, der wiederverwendet werden soll
* Der Name einer Hook-Funktion muss mit `use` anfangen
* Die Signatur einer Hook-Funktion (R√ºckgabe-Wert und Parameter) kannst du frei w√§hlen. 
  * Allerdings d√ºrfen Hook-Funktionen nicht asynchron sind
---
### Custom Hooks mit TanStack Query
* Wenn Du einen Query in mehreren Komponenten verwenden willst, kannst Du dessen Code in Custom Hooks auslagern
* Selbst wenn du einen Query nur in einer Komponente verwendest, kann es sinnvoll sein, diesen auszulagern:
  * Man kann ihn insoliert testen
  * Der "technische" Code der Komponente wird verringert, was evtl. zu besserer lesbarkeit f√ºhrt

* ```typescript
  function useBlogListQuery() {
    return useQuery({ /* ... */ });
  }

  function PostListPage() {
    const result = useBlogListQuery();
  }

  function App() {
    const result = useBlogListQuery();
  }
  ```
---
## √úbung: Ein Custom Hook zum Laden eines einzelnen Blog-Post
* In der `PostPage` soll der gew√§hlte Post mit einem Query geladen werden.
* Au√üerdem soll (neu!) in der Sidebar der Post mit der Id `P10` geladen und angezeigt werden
* Kannst du einen eigenen Hook bauen, der den BlogPost mit einer angegebene Id l√§dt?
  * Den `fetch`-Code f√ºr die `queryFn` kannst Du aus `PostPage` √ºbernehmen
* Stelle dann `PostPage` um, so dass diese Komponente deinen Hook verwendet
* Verwende dann deinen Hook um in `Sidebar` das Blog-Post mit Id `P10` zu laden und daraus `title` und `likes` anzuzeigen
* L√∂sung: `steps/30_custom_hook` 
  
---
## Validieren von Daten

---
### Validieren von Daten
* <!-- .element: class="demo" --> Au√üerhalb des Projektes, in einer TypeScript-Datei:
* <!-- .element: class="demo" --> fetch-Ergebnis ist any in TypeScript
* <!-- .element: class="demo" --> zod
---
### Validieren von Daten
<!-- .slide: class="left" -->
- Das Ergebnis eines `fetch`-Calls ist aus TypeScript-Sicht ein Promise von `any`
- Wir k√∂nnen das Ergebnis also verwenden, ohne weitere Typ-Angaben zu verwenden:
* ```typescript
  async function loadPost(postId: string) {
    const response = await fetch("...");
    const data = await response.json();
    //      ^-- data ist 'any'
    return data;
  }
  ```
- Mit `data` bzw. dem R√ºckgabewert von loadPost k√∂nnen wir alles machen - unabh√§ngig davon, ob das richtig ist oder nicht:
* ```typescript
  const data = await loadPost("P10");
  const title = data.title; // wahrscheinlich ok, weil title in blog post vorhanden ist
  const blogPost = data[2]; // wahrscheinlich nicht ok, weil data kein Array ist
  const title = data.toUpperCase(); // wahrscheinlich nicht ok, weil data kein string ist
  ```
* Wir haben hier keinen Support von TypeScript!  
---
### Validieren
<!-- .slide: class="left" -->
* Wir k√∂nnen einen Typecast verwenden, um TypeScript den R√ºckgabe-Typen mitzuteilen:
* ```typescript
  async function loadPost(postId: string): Promise<BlogPost> {
    const response = await fetch("...");
    const data = await response.json();
    //      ^-- data ist 'any'
    return data as BlogPost;
    //          ^--  Typecast
  }
  ```
* Ist das gut? Welche Probleme k√∂nnte es nun geben? ü§î
---
### Typecast vs. Validierung
<!-- .slide: class="left" -->
- Mit einem Typecast sagen wir TypeScript welchen Typ eine Variablen haben soll
* Das kann richtig oder falsch sein:
* ```typescript
  const s:string = "Hallo";
  let y:any = s;
  let x:number = y as number; üôÄ
  ```
- In unserem Beispiel sind wir uns sicher, dass `data` ein `BlogPost`-Objekt ist.
* Oder? ü§î
---
### Validierung
<!-- .slide: class="left" -->
* Die Daten, die von einem Server (oder auch aus Benutzereingaben) kommen, k√∂nnen von TypeScript nicht √ºberpr√ºft werden
* TypeScript ist zu Laufzeit "weg"
* Wenn der Server also Daten schickt die - entgegen unserer Erwartung - nicht zu dem passen, was wir als TypeScript-Typ definiert haben, merken wir das nicht
  * (abgesehen davon, dass die Anwendung irgendwann in Fehler l√§uft)
* Besser w√§re bei solchen Daten eine echte Laufzeit-Validierung
* Dabei werden die gelesen Daten nach dem Empfang √ºberpr√ºft:
* ```typescript
  async function loadPost(postId: string): Promise<BlogPost> {
    const response = await fetch("...");
    const data = await response.json();
    if (typeof data !== "object") {
      // Fehler!
    }
    if (!"title" in data) { /* Fehler! */ }
    if (!"body" in data) { /* Fehler! */ }
    // ...
    // ok: data ziemlich sicher BlogPost
    return data as BlogPost;
  }
  ```
* Ist das sch√∂n?
---
### Probleme mit manueller Validierung

* Validierung kann viel Code in Anspruch nehmen
* Au√üerdem redundant: 
  * wir m√ºssen den Code zur Validierung schreiben (Laufzeit)
  * wir m√ºssten den TypeScript-Code schreiben (Buildzeit)
---
### Validierungsbibliothek: zod
<!-- .slide: class="left" -->
- Mit [zod](https://zod.dev) gibt es eine Validierungsbibliothek, die beides verbindet
- Mit (JavaScript)-Code, der auch zur Laufzeit ausgef√ºhrt wird, wird ein **Schema** beschrieben
- Dieses Schema kann zur Laufzeit verwendet werden, um ein beliebiges Objekt zu validieren
- Au√üerdem kann aus dem Schema ein TypeScript-Type f√ºr die Build-Zeit abgeleitet werden
* ```typescript
  import { z } from "zod";

  const UserSchema = z.object({
    username: z.string(),
    email: z.email(),
    nickname: z.string().nullish()
  });
  ```
---
### Zod
* Mit dem `z`-Objekt lassen sich Typen (einfache und komplexe) beschreiben
* Objekte werden mit [`z.object`](https://zod.dev/?id=objects) beschrieben
* Dabei kann man nicht nur Typen angeben ([`string`, `number`](https://zod.dev/?id=primitives), `email`, ....) sondern auch Wertebeschr√§nkungen
  * [Mindestl√§nge, Maximall√§nge](https://zod.dev/?id=minmaxlength), erlaubte Zeichen etc.
* Mit der [`parse`-Methode](https://zod.dev/?id=parse) am `Schema`-Objekt kann dann ein beliebiges Objekt validiert werden.
* Wenn das Objekt nicht dem Schema entspricht, wird ein Fehler geworfen
* Wenn alles in Ordnung ist, kommt das validierte Objekt zur√ºck
* ```typescript
  const potentialUser = await loadUser("U1");

  const user = UserSchema.parse(potentialUser);
  ```
* Dadurch ist auch TypeScript der Typ bekannt!
* ```typescript
  type User = { username: string; email: string; nickname?: string | null };
  const user: User = UserSchema.parse(potentialUser);
                     // ^--- ok
  
  ```
---
### Zod: Ableiten des TypeScript-Typen  
* Den TypeScript-Typen m√ºssen wir gar nicht selber schreiben, dass kan zod f√ºr uns machen:
* ```typescript
  export const UserSchema = z.object({ /* ... */ });
  export type User = z.infer<typeof UserSchema>
  ```
---
### √úbung: zod

* Erweitere deinen Custom-Hook zum Laden eines BlogPosts um die Validierung mit zod!
* Definiere das Schema des BlogPost-Objektes (als Vorlage soll der fertige `BlogPost`-Type in `types.ts` dienen)
* Das `title`-Feld soll eine Maximall√§nge von 40 Zeichen haben.
* Das `likes`-Feld muss optional sein!
* Nach dem Laden der Daten mit TanStack Query soll das geladenen Objekt dann validiert werden
  * Wenn Du den Post "Something to remember when learning new tech" (ID: "P5") √∂ffnest, sollte eine Fehlermeldung erscheinen, weil dessen Titel l√§nger als 40 Zeichen ist
  * Das dauert eine Zeit, weil TanStack Query bei einem Fehler automatisch mehrere weitere versuche unternimmt, die Daten zu laden
  * Erst danach wird dann die Fehlermeldung gerendert
* L√∂sung: `steps/32_zod`



---
### Caching

* Alle gelesenen Daten werden in einem globalen Cache gehalten
* üëâ Dev Tools!
* Es gibt verschiedene Strategien, wie die Daten im Cache aktualisiert werden

---
### (Automatisches) Aktualisieren von Daten

* Alle Query-Ergebnisse von `useQuery` werden automatisch gecached
* Alle Komponenten werden aktualisiert, wenn sich der Cache aktualisiert
* Alle Daten im Cache werden als "stale" (veraltet) angesehen
* [Per Default](https://tanstack.com/query/latest/docs/react/guides/important-defaults) werden Queries deswegen automatisch neu ausgef√ºhrt:
* Komponente wird (neu) gemounted
* Browser-Fenster bekommt den Focus
* Nachdem das Netzwerk offline war

---

### Manuelles Aktualisieren von Queries

* Queries k√∂nnen per API manuell erneut ausgef√ºhrt werden
* Das kann zum Beispiel nach einer Mutation sinnvoll sein, um die ge√§nderten/gespeicherten Daten 
im Cache zu aktualisieren
* Dazu wird die Funktion [`invalidateQueries`](https://tanstack.com/query/latest/docs/react/reference/QueryClient#queryclientinvalidatequeries) vom `QueryClient` verwendet
* √úbergeben werden die Query Keys, deren Queries erneut ausgef√ºhrt werden sollen
* ```typescript
  import { useMutation, useQueryClient } from "react-query";
  import { savePost } from "./blog-api";

  function PostEditorPage() {
    const queryClient = useQueryClient();
    const mutation = useMutation({
      mutationFn: savePost, 
      onSuccess() {
        // PostPage-Query erneut ausf√ºhren, wenn Mutation erfolgreich war
        queryClient.invalidateQueries(['posts']);
      }
    });

    // ...
  }
  ```

---

### Beispiel: Blog-Post nicht neuladen

* Ein einzelnes BlogPost kann im Cache verbleiben, da es sich in unserer App nicht √§ndert/nicht √§ndern kann
* Mit den `refetch`-Funktionen kann die automatische Aktualisierung ausgeschaltet werden
* ```typescript
  function PostPage() {
    // ...
    const result = useQuery({queryKey: ["blogPost", postId], queryFn: () => loadBlogPost(postId)}, {
      refetchOnMount: false,
      refetchOnWindowFocus: false
    });  

    // ...
  }
  ```

---

### Refetch

* Das von `useQuery` zur√ºckgeliefert Objekt enth√§lt auch eine `refetch`-Funktion um einen Query
manuell neu auszuf√ºhren
* ```typescript
  function PostListPage() {
    const result = useQuery({queryKey: ['posts'], queryFn: readPosts}, {
      // nicht automatisch aktualisieren
      refetchOnMount: false, refetchOnWindowFocus: false
    })

    // ... result.status === loading, status === error ... 

    return <div>
      <button onClick={refetch}>Reload Posts</button>
      <PostList posts={data} />
    </div>
  }
  ```
---
## √úbung: Arbeiten mit dem Cache
* In der `Sidebar` und/oder `Post`-Komponente soll ein Blog-Post "geliked" werden k√∂nnen
* Kopiere dazu die Datei `material/use-like-mutation.ts` in dein `src`-Verzeichnis
* Darin ist eine Mutation die f√ºr ein angegebenen Blog Post einen "Like" vergibt
* F√ºge in der `Sidebar` einen "Like"-Button hinzu, der die Mutation verwendet
* Stelle sicher, dass die neue "Like"-Anzahl sowohl in der `BlogPost`- als auch in der `Sidebar`-Komponente korrekt dargestellt wird
  * mit einem reload-Button, mit `invalidateQueries` mit `onSuccess` oder wie auch immer
* L√∂sung: `steps/34_caching_mutation`


---
## Suspense

* Suspense ist ein relativ neuer Mechanismus in React, um das Arbeiten mit asynchronem Code (insb. Data Fetching) zu vereinfachen
* Suspense unterbricht das Rendern, wenn eine Komponente wegen noch fehlender Daten nicht gerendert werden kann
  * Daten k√∂nnen "normale" Daten sein, die z.B. mit TanStack Query geladen werden
  * ...oder Source-Code, der mit Lazy Loading erst bei Bedarf nachgeladen wird
---
### Suspense f√ºr Lazy-Loading
* Suspense f√ºr Lazy-Loading/Code Splitting gibt es schon l√§nger als stabiles Feature in React
* Bei Lazy Loading wird der Code f√ºr eine Komponente erst geladen, wenn er ben√∂tigt wird
* ```typescript
  import { lazy } from 'react';

  
  const PostEditor = lazy(() => import('./PostEditor'));
  ```
* Der Source-Code f√ºr `PostEditor` wird vom Browser erst geladen, wenn die Komponente ben√∂tigt bzw. verwendet wird
* W√§hrend der Source-Code geladen wird, muss React einen Platzhalter anzeigen
* Dazu kann um eine Komponente die `Suspense`-Komponente von React gelegt werden
* ```typescript
  const PostEditor = lazy(() => import('./PostEditor'));
  
  function PostEditorPage() {
    // ...
  
    return  <React.Suspense> fallback={"Please wait"}>
      <PostEditor />
    </React.Suspense>;
  }
  ```
* Hier w√ºrde React zun√§chst die `fallback`-Komponente (`Please wait`) rendern und darstellen, bis der Source-Code f√ºr `PostEditor` geladen wurde
* Danach rendert React die Komponente (`PostEditorPage`) erneut und kann nun den `PostEditor` darstellen.

---
### Suspense f√ºr Daten ("Suspense for Data Fetching")
* Um Suspense mit fetch o.√§. zu verwenden, muss die eingesetzte Bibliothek Suspense unterst√ºtzen
  * Das k√∂nnen wir in unserem eigenen Code nicht machen
  * TanStack Query, React Router und der Apollo GraphQL Client unterst√ºtzen Suspense in ihren neusten Versionen
---
### Suspense mit TanStack Query 

* Die Verwendung mit TanStack Query ist denkbar einfach: ihr verwendet den `useSuspenseQuery`-Hook statt des `useQuery`-Hooks
* Die Parameter sind dieselben
* Aber: der Query liefert erst ein Ergebnis, wenn die Daten geladen worden sind (oder im Cache vorhanden sind)
  * F√ºr die Dauer der Ladezeit muss `Suspense` verwendet werden, um eine Platzhalter-Komponente zu rendern
  * F√ºr den Fall eines Fehlers muss eine [Error-Boundary-Komponente](https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary) gesetzt werden
    * Das ist eine Art try-catch-Mechanismus, mit dem eine React-Anwendung auf Fehler _w√§hrend des Renderns_ reagieren kann

* ```typescript
  function Post({postId}) {
    // hier wird das Rendern von React unterbrochen, bis die Daten da sind:
    const data = useSuspenseQuery({queryFn: fetch(/*...*/), queryKey: ["post", postId] });
    // wenn die Anwendung hierher kommt, sind die Daten in jedem Fall vorhanden
    return ...;
  }

  function PostPage() {
    return (
      <ErrorBoundary fallback={<h1>Loading failed!</h1>}>      
        <Suspense fallback={<h1>Post P10 loading...</h1>}>
          <Post postId="P10" />
        </Suspense>
      </ErrorBoundary>
    )
  }
  ```
---
### Error Boundary
- Eine Error Boundary-Komponente kann man grunds√§tzlich selbst bauen
- Fehler, die beim Rendern unterhalb einer Error-Boundary-Komponente auftreten, werden als eine Art Propertie in die n√§chsth√∂here Error-Boundary-Komponente gegeben
  - √§hnlich wie try/catch
- Die Komponente kann dann eine Fehlermeldung o.√§. rendern  
- Ihr k√∂nnt damit sehr feingranular steuern, wo Fehler angezeigt werden sollen (wenn _eine_ Abfrage nicht funktioniert, k√∂nnen die anderen weiterlaufen - oder nicht)
- Es gibt eine fertige, generische Error-Boundary-Komponente: [react-error-boundary](https://www.npmjs.com/package/react-error-boundary)
- Auch TanStack Query hat eine Error-Boundary-Komponente, [QueryErrorResetBoundary](https://tanstack.com/query/latest/docs/framework/react/reference/QueryErrorResetBoundary)
  - Mit dieser gibt es die M√∂glichkeit, einen fehlerhaften Query wiederholen zu lassen (auch durch User-Interaktion, z.B. Button click)

---
### Priorisierung
* Mit Suspense k√∂nnt ihr einzelne Teile der UI priorisieren
* Ihr k√∂nnt z.B. steuern, welche Teile schon dargestellt werden sollen, auch wenn noch andere Daten fehlen
* ...oder das auf _alle_ Daten gewartet werden soll
* Was jeweils "richtig" ist, h√§ngt von den fachlichen Anforderungen ab
---
### Priorisierung
* In der `PostPage` werden Daten aus zwei Requests ben√∂tigt: der Blog-Post und Informationen √ºber dessen Autoren
* Beide Requests k√∂nnen zeitgleich (oder nacheinander) gestartet werden
* Durch das Festlegen der Suspense-Komponente k√∂nnt ihr ausdr√ºcken, welche Teile wichtig sind (sofort rendern, sobald Daten da sind), oder "unwichtig"
* Was passiert hier:
* ```typescript
  function PostPage() {
    const {data: user} = useSuspenseQuery(/* User */);
    const {data: post} = useSuspenseQuery(/* Post */);

    // ...
  }
  ```
* React rendert Komponente bis zum ersten `useSuspenseQuery`
* Wenn die Daten da sind, wird die Komponente nochmal gerendert
* Diesmal bis zum zweiten `useSuspenseQuery`
* Die Daten werden also *nacheinander* nicht *parallel* geladen. üò¢
---
### Priorisierung mit TanStack Query
* Um die Daten parallel zu laden, k√∂nnt ihr TanStack Query anweisen, Daten in den Cache zu laden, *ohne* darauf zu warten
* Dazu verwendet ihr `QueryClient.ensureData`, das die selben Parameter wie `useSuspenseQuery` bzw. `useQuery` entgegennimmt
* TanStack Query startet dann den Request im Hintergrund (und legt die Daten in den Cache, sobald sie vorliegen)
* Um also *nicht* auf die User-Daten zu warten k√∂nnt ihr folgendes tun:
* ```typescript
  function PostPage({postId}) {
    const queryClient = useQueryClient();
    queryClient.ensureData({queryFn: /* ... */, queryKey: ["post", postId, "user"]}); 
    const {data: post} = useSuspenseQuery(/* Post */);

    return ...;
  }
  ```
* Hier werden beide Requests gestartet und React wartet dann auf das Ergebnis des Post-Queries
* In einer weiteren Komponente k√∂nntet ihr dann auf die User-Daten warten, die im besten Fall dann sogar schon im Cache sind:
* ```typescript
  function User({postId}) {
    // Query-Key muss mit dem Query-Key von oben √ºbereinstimmen!
    const data = useSuspenseQuery({queryFn: /* ... */, queryKey: ["post", postId, "user"]}); 

    // User-Daten rendern

    return ...;
  }
  ```
---
## √úbung: Suspense

* Die `PostPage` soll den BlogPost *und* User-Daten anzeigen
* Die Queries f√ºr das Laden der User-Daten sind bereits fertig 
  * kopiere bitte die Dateien `material/use-user-query.ts` und `material/UserDetails.tsx` in dein `src`-Verzeichnis
* Integriere die `UserDetails`-Komponente in die `PostPage`-Komponente  
  * Lege darum herum eine `Suspense`-Komponente. 
* Stelle nun `get-post.ts` auf `useSuspenseQuery` um
* Kannst Du die `PostPage`-Komponente so bauen, dass...
  - ...beide Komponenten (Post und UserDetails) erst gerendert werden, wenn f√ºr *beide* Komponenten die Daten geladen wurden
  - ...die Komponenten jeweils sofort gerendert werden, wenn ihre jeweiligen Daten vorhanden sind
* Hinweise:
  * Du kannst Du Lade-Zeiten mit `?slow=TIMEOUT_IN_MS` in den URLs verz√∂gern
  * Am besten funktioniert Suspense, wenn Du erst die Blogliste aufrufst, und dort dann einen BlogPost anklickst
* L√∂sung: `steps/45_suspense_02`
---
## Ausblick: Routing mit Data Fetching

* Der React Router ist ebenfalls in der Lage, das Laden von Daten f√ºr eine Route zu koordinieren
* Das geht mit oder ohne Suspense
* Dazu gebt ihr bei der Routen-Definition einer `loader`-Funktion an
* Dieser Funktion werden die Routen-Parameter √ºbergeben.
* Sie liefert ein Promise mit den zu ladenen Daten zur√ºck
* ```typescript
  <Route path="/post/:postId" 
    loader={ async (params) => { /* fetch ... */ } }
    component={PostPage} 
  } />
  ```
* Auf die gelesenen Daten k√∂nnt ihr dann in der Komponente mit `useLoaderData` zugreifen:
* ```typescript
  function PostPage() {
    const post = useLoaderData(); // R√ºckgabewert der loader-Funktion
  }
  ```
* Um Caching etc. zu verwenden k√∂nnt ihr in der `loader`-Funktion auch  den `QueryClient` von TanStack Query verwenden, um die Daten zu verwenden
* Ist das eine gute Idee? ü§î


<!-- 

## √úbung: Die Blog-Anwendung mit TanStack Query

* _Vervollst√§ndige den Query zum Laden und Speichern mit TanStack Query_
* Backend starten
* Das Backend ist bereits fertig. Du kannst es starten mit:
* ```
cd blog-example/backend-rest
npm install (nur, falls noch nicht gemacht)
npm start
```
* Danach sollte unter [http://localhost:7000/posts](http://localhost:7000/posts) 
die Liste mit den (JSON-)Posts zur√ºckkommen
* Schritte:
* Kopiere `index.js` und `App.js` aus `material/4-remote-query` in dein `src`-Verzeichnis
* In `App.js` findest Du TODOs mit weiteren Hinweisen
* M√∂gliche L√∂sung findest Du in `steps/4-remote-query`
* Wenn Du fertig bist, bitte "Hand heben" in Teams üôã‚Äç‚ôÄÔ∏è

--- -->    
  </textarea
          >
        </section>

        <!-- ============================================================================= -->
        <section>
          <h2>Geschafft! üòä</h2>
          <h3>Vielen Dank f√ºr Eure Teilnahme!</h3>
          <h3>Viel Spa√ü und Erfolg mit React!</h3>
          <p>Wenn ihr noch Fragen habt, k√∂nnt ihr mich erreichen:</p>
          <p>
            Mail:
            <a href="mailto:nils@nilshartmann.net">nils@nilshartmann.net</a>
          </p>
          <p>
            Web:
            <a href="https://nilshartmann.net" target="_blank"
              >https://nilshartmann.net</a
            >
          </p>
          <p>
            Twitter:
            <a href="https://twitter.com/nilshartmann" target="_blank"
              >@nilshartmann</a
            >
          </p>
        </section>
      </div>
    </div>

    <script src="slides/revealjs/reveal.js/dist/reveal.js"></script>
    <script src="slides/revealjs/reveal.js/plugin/notes/notes.js"></script>
    <script src="slides/revealjs/reveal.js/plugin/markdown/markdown.js"></script>
    <script src="slides/revealjs/reveal.js/plugin/highlight/highlight.js"></script>
    <script src="slides/revealjs/config.js"></script>
  </body>
</html>
